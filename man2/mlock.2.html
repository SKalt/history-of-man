<!--
Copyright (C) Markus Kuhn, 1996
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of MLOCK</TITLE>
</HEAD><BODY>
<H1>MLOCK</H1>
Section: Linux Programmer's Manual (2)<BR>Updated: 2004-05-27<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

mlock - disable paging for some parts of memory
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<PRE>
<B>#include &lt;<A HREF="file:///usr/include/sys/mman.h">sys/mman.h</A>&gt;</B>

<B>int mlock(const void *</B><I>addr</I><B>, size_t </B><I>len</I><B>);
</B></PRE>

<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<B>mlock</B>

disables paging for the memory in the range starting at
<I>addr</I>

with length
<I>len</I>

bytes. All pages which contain a part of the specified memory range
are guaranteed be resident in RAM when the
<B>mlock</B>

system call returns successfully and they are guaranteed to stay in RAM
until the pages are unlocked by
<B>munlock</B>

or
<B>munlockall</B>,

until the pages are unmapped via
<B>munmap</B>,

or until the process terminates or starts another program with
<B>exec</B>.

Child processes do not inherit page locks across a
<B>fork</B>.

<P>
Memory locking has two main applications: real-time algorithms and
high-security data processing. Real-time applications require
deterministic timing, and, like scheduling, paging is one major cause
of unexpected program execution delays. Real-time applications will
usually also switch to a real-time scheduler with 
<B>sched_setscheduler</B>.

Cryptographic security software often handles critical bytes like
passwords or secret keys as data structures. As a result of paging,
these secrets could be transferred onto a persistent swap store medium,
where they might be accessible to the enemy long after the security
software has erased the secrets in RAM and terminated.
(But be aware that the suspend mode on laptops and some desktop
computers will save a copy of the system's RAM to disk, regardless
of memory locks.)
<P>
Memory locks do not stack, i.e., pages which have been locked several times
by calls to
<B>mlock</B>

or
<B>mlockall</B>

will be unlocked by a single call to
<B>munlock</B>

for the corresponding range or by
<B>munlockall</B>.

Pages which are mapped to several locations or by several processes stay
locked into RAM as long as they are locked at least at one location or by
at least one process.
<P>
On POSIX systems on which
<B>mlock</B>

and
<B>munlock</B>

are available,
<B>_POSIX_MEMLOCK_RANGE</B>

is defined in &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt; and the value
<B>PAGESIZE</B>

from &lt;<A HREF="file:///usr/include/limits.h">limits.h</A>&gt; indicates the number of bytes per page.
<A NAME="lbAE">&nbsp;</A>
<H2>NOTES</H2>

With the Linux system call,
<I>addr</I>

is automatically rounded down to the nearest page boundary.  
However, POSIX 1003.1-2001 allows an implementation to require that
<I>addr</I>

is page aligned, so portable applications should ensure this.
<A NAME="lbAF">&nbsp;</A>
<H2>RETURN VALUE</H2>

On success,
<B>mlock</B>

returns zero.  On error, -1 is returned,
<I>errno</I>

is set appropriately, and no changes are made to any locks in the
address space of the process.
<A NAME="lbAG">&nbsp;</A>
<H2>ERRORS</H2>

<DL COMPACT>
<DT><B>EINVAL</B>

<DD>
(Not on Linux)
<I>addr</I>

was not a multiple of the page size.
<DT><B>ENOMEM</B>

<DD>
Some of the specified address range does not correspond to mapped
pages in the address space of the process or the process tried to
exceed the maximum number of allowed locked pages.
<DT><B>EPERM</B>

<DD>
The calling process has insufficient privilege to call 
<B>mlock</B>.

Under Linux the
<B>CAP_IPC_LOCK</B>

capability is required.
</DL>
<P>

Linux adds
<DL COMPACT>
<DT><B>EINVAL</B>

<DD>
<I>len</I>

was negative.
</DL>
<A NAME="lbAH">&nbsp;</A>
<H2>CONFORMING TO</H2>

POSIX.1b, SVr4.  SVr4 documents an additional EAGAIN error code.
<A NAME="lbAI">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="../man2/mlockall.2.html">mlockall</A></B>(2),

<B><A HREF="../man2/munlock.2.html">munlock</A></B>(2),

<B><A HREF="../man2/munlockall.2.html">munlockall</A></B>(2),

<B><A HREF="../man2/munmap.2.html">munmap</A></B>(2),

<B><A HREF="../man2/setrlimit.2.html">setrlimit</A></B>(2),

<B><A HREF="../man7/capabilities.7.html">capabilities</A></B>(7)

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">NOTES</A><DD>
<DT><A HREF="#lbAF">RETURN VALUE</A><DD>
<DT><A HREF="#lbAG">ERRORS</A><DD>
<DT><A HREF="#lbAH">CONFORMING TO</A><DD>
<DT><A HREF="#lbAI">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 02:09:59 GMT, April 20, 2020
</BODY>
</HTML>
