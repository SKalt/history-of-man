<!--
Copyright (C) Markus Kuhn, 1996
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of MLOCKALL</TITLE>
</HEAD><BODY>
<H1>MLOCKALL</H1>
Section: Linux Programmer's Manual (2)<BR>Updated: 2004-05-27<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

mlockall - disable paging for calling process
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<PRE>
<B>#include &lt;<A HREF="file:///usr/include/sys/mman.h">sys/mman.h</A>&gt;</B>

<B>int mlockall(int </B><I>flags</I><B>);
</B></PRE>

<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<B>mlockall</B>

disables paging for all pages mapped into the address space of the
calling process. This includes the pages of the code, data and stack
segment, as well as shared libraries, user space kernel data, shared
memory and memory mapped files. All mapped pages are guaranteed to be
resident in RAM when the
<B>mlockall</B>

system call returns successfully and they are guaranteed to stay in RAM
until the pages are unlocked again by
<B>munlock</B>

or
<B>munlockall</B>

or until the process terminates or starts another program with
<B>exec</B>.

Child processes do not inherit page locks across a
<B>fork</B>.

<P>
Memory locking has two main applications: real-time algorithms and
high-security data processing. Real-time applications require
deterministic timing, and, like scheduling, paging is one major cause
of unexpected program execution delays. Real-time applications will
usually also switch to a real-time scheduler with
<B>sched_setscheduler</B>.

Cryptographic security software often handles critical bytes like
passwords or secret keys as data structures. As a result of paging,
these secrets could be transfered onto a persistent swap store medium,
where they might be accessible to the enemy long after the security
software has erased the secrets in RAM and terminated. For security
applications, only small parts of memory have to be locked, for which
<B>mlock</B>

is available.
<P>
The 
<I>flags</I>

parameter can be constructed from the bitwise OR of the following
constants:
<DL COMPACT>
<DT><B>MCL_CURRENT</B>

<DD>
Lock all pages which are currently mapped into the address space of
the process.
<DT><B>MCL_FUTURE</B>

<DD>
Lock all pages which will become mapped into the address space of the
process in the future. These could be for instance new pages required
by a growing heap and stack as well as new memory mapped files or
shared memory regions.
</DL>
<P>

If
<B>MCL_FUTURE</B>

has been specified and the number of locked pages exceeds the upper
limit of allowed locked pages, then the system call which caused the
new mapping will fail with
<B>ENOMEM</B>.

If these new pages have been mapped by the the growing stack, then the
kernel will deny stack expansion and send a 
<B>SIGSEGV</B>.

<P>
Real-time processes should reserve enough locked stack pages before
entering the time-critical section, so that no page fault can be
caused by function calls. This can be achieved by calling a function
which has a sufficiently large automatic variable and which writes to
the memory occupied by this large array in order to touch these stack
pages. This way, enough pages will be mapped for the stack and can be
locked into RAM. The dummy writes ensure that not even copy-on-write
page faults can occur in the critical section.
<P>
Memory locks do not stack, i.e., pages which have been locked several times
by calls to
<B>mlockall</B>

or
<B>mlock</B>

will be unlocked by a single call to
<B>munlockall</B>.

Pages which are mapped to several locations or by several processes stay
locked into RAM as long as they are locked at least at one location or by
at least one process.
<A NAME="lbAE">&nbsp;</A>
<H2>RETURN VALUE</H2>

On success,
<B>mlockall</B>

returns zero.  On error, -1 is returned, and
<I>errno</I>

is set appropriately.
<A NAME="lbAF">&nbsp;</A>
<H2>ERRORS</H2>

<DL COMPACT>
<DT><B>EINVAL</B>

<DD>
Unknown flags were specified.
<DT><B>ENOMEM</B>

<DD>
The process tried to exceed the maximum number of allowed locked
pages.
<DT><B>EPERM</B>

<DD>
The calling process has insufficient privilege to call 
<B>mlockall</B>.

Under Linux the
<B>CAP_IPC_LOCK</B>

capability is required.
</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>AVAILABILITY</H2>

On POSIX systems on which
<B>mlockall</B>

and
<B>munlockall</B>

are available,
<B>_POSIX_MEMLOCK</B>

is defined in &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt; to a value greater than 0. (See also
<B><A HREF="../man3/sysconf.3.html">sysconf</A></B>(3).)




<A NAME="lbAH">&nbsp;</A>
<H2>CONFORMING TO</H2>

POSIX.1b, SVr4.   SVr4 documents an additional EAGAIN error code.
<A NAME="lbAI">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="../man2/mlock.2.html">mlock</A></B>(2),

<B><A HREF="../man2/munlock.2.html">munlock</A></B>(2),

<B><A HREF="../man2/munlockall.2.html">munlockall</A></B>(2),

<B><A HREF="../man3/sysconf.3.html">sysconf</A></B>(3),

<B><A HREF="../man7/capabilities.7.html">capabilities</A></B>(7)

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">RETURN VALUE</A><DD>
<DT><A HREF="#lbAF">ERRORS</A><DD>
<DT><A HREF="#lbAG">AVAILABILITY</A><DD>
<DT><A HREF="#lbAH">CONFORMING TO</A><DD>
<DT><A HREF="#lbAI">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 02:09:59 GMT, April 20, 2020
</BODY>
</HTML>
