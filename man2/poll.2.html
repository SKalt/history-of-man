<!--
Copyright (C) 2006, 2019 Michael Kerrisk &lt;mtk.manpages@gmail.com&gt;
%%%LICENSE_START(VERBATIM)
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
.\"
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.
.\"
Since the Linux kernel and libraries are constantly changing, this
manual page may be incorrect or out-of-date.  The author(s) assume no
responsibility for errors or omissions, or for damages resulting from
the use of the information contained herein.  The author(s) may not
have taken the same level of care in the production of this manual,
which is licensed free of charge, as they might when working
professionally.
.\"
Formatted or processed versions of this manual, if unaccompanied by
the source, must acknowledge the copyright and authors of this work.
%%%LICENSE_END
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of POLL</TITLE>
</HEAD><BODY>
<H1>POLL</H1>
Section: Linux Programmer's Manual (2)<BR>Updated: 2020-04-11<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

poll, ppoll - wait for some event on a file descriptor
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<PRE>
<B>#include &lt;<A HREF="file:///usr/include/poll.h">poll.h</A>&gt;</B>

<B>int poll(struct pollfd *</B><I>fds</I><B>, nfds_t </B><I>nfds</I><B>, int </B><I>timeout</I><B>);</B>

<B>#define _GNU_SOURCE</B>         /* See <A HREF="../man7/feature_test_macros.7.html">feature_test_macros</A>(7) */
<B>#include &lt;<A HREF="file:///usr/include/signal.h">signal.h</A>&gt;</B>
<B>#include &lt;<A HREF="file:///usr/include/poll.h">poll.h</A>&gt;</B>

<B>int ppoll(struct pollfd *</B><I>fds</I><B>, nfds_t </B><I>nfds</I><B>, </B>
<B>        const struct timespec *</B><I>tmo_p</I><B>, const sigset_t *</B><I>sigmask</I><B>);</B>
</PRE>

<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<B>poll</B>()

performs a similar task to
<B><A HREF="../man2/select.2.html">select</A></B>(2):

it waits for one of a set of file descriptors to become ready
to perform I/O.
The Linux-specific
<B><A HREF="../man7/epoll.7.html">epoll</A></B>(7)

API performs a similar task, but offers features beyond those found in
<B><A HREF="../man2/poll.2.html">poll</A></B>(2).

<P>

The set of file descriptors to be monitored is specified in the
<I>fds</I>

argument, which is an array of structures of the following form:
<P>



struct pollfd {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;&nbsp;&nbsp;fd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;file&nbsp;descriptor&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;events;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;requested&nbsp;events&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;short&nbsp;revents;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;returned&nbsp;events&nbsp;*/
};


<P>

The caller should specify the number of items in the
<I>fds</I>

array in
<I>nfds</I>.

<P>

The field
<I>fd</I>

contains a file descriptor for an open file.
If this field is negative, then the corresponding
<I>events</I>

field is ignored and the
<I>revents</I>

field returns zero.
(This provides an easy way of ignoring a
file descriptor for a single
<B>poll</B>()

call: simply negate the
<I>fd</I>

field.
Note, however, that this technique can't be used to ignore file descriptor 0.)
<P>

The field
<I>events</I>

is an input parameter, a bit mask specifying the events the application
is interested in for the file descriptor
<I>fd</I>.

This field may be specified as zero,
in which case the only events that can be returned in
<I>revents</I>

are
<B>POLLHUP</B>,

<B>POLLERR</B>,

and
<B>POLLNVAL</B>

(see below).
<P>

The field
<I>revents</I>

is an output parameter, filled by the kernel with the events that
actually occurred.
The bits returned in
<I>revents</I>

can include any of those specified in
<I>events</I>,

or one of the values
<B>POLLERR</B>,

<B>POLLHUP</B>,

or
<B>POLLNVAL</B>.

(These three bits are meaningless in the
<I>events</I>

field, and will be set in the
<I>revents</I>

field whenever the corresponding condition is true.)
<P>

If none of the events requested (and no error) has occurred for any
of the file descriptors, then
<B>poll</B>()

blocks until one of the events occurs.
<P>

The
<I>timeout</I>

argument specifies the number of milliseconds that
<B>poll</B>()

should block waiting for a file descriptor to become ready.
The call will block until either:
<DL COMPACT>
<DT>&bull;<DD>
a file descriptor becomes ready;
<DT>&bull;<DD>
the call is interrupted by a signal handler; or
<DT>&bull;<DD>
the timeout expires.
</DL>
<P>

Note that the
<I>timeout</I>

interval will be rounded up to the system clock granularity,
and kernel scheduling delays mean that the blocking interval
may overrun by a small amount.
Specifying a negative value in
<I>timeout</I>

means an infinite timeout.
Specifying a
<I>timeout</I>

of zero causes
<B>poll</B>()

to return immediately, even if no file descriptors are ready.
<P>

The bits that may be set/returned in
<I>events</I>

and
<I>revents</I>

are defined in <I>&lt;<A HREF="file:///usr/include/poll.h">poll.h</A>&gt;</I>:
<DL COMPACT>
<DT><B>POLLIN</B>

<DD>
There is data to read.
<DT><B>POLLPRI</B>

<DD>
There is some exceptional condition on the file descriptor.
Possibilities include:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT>&bull;<DD>
There is out-of-band data on a TCP socket (see
<B><A HREF="../man7/tcp.7.html">tcp</A></B>(7)).

<DT>&bull;<DD>
A pseudoterminal master in packet mode has seen a state change on the slave
(see
<B><A HREF="../man2/ioctl_tty.2.html">ioctl_tty</A></B>(2)).

<DT>&bull;<DD>
A
<I>cgroup.events</I>

file has been modified (see
<B><A HREF="../man7/cgroups.7.html">cgroups</A></B>(7)).

</DL>
</DL>

<DT><B>POLLOUT</B>

<DD>
Writing is now possible, though a write larger that the available space
in a socket or pipe will still block (unless
<B>O_NONBLOCK</B>

is set).
<DT><B>POLLRDHUP</B> (since Linux 2.6.17)

<DD>
Stream socket peer closed connection,
or shut down writing half of connection.
The
<B>_GNU_SOURCE</B>

feature test macro must be defined
(before including
<I>any</I>

header files)
in order to obtain this definition.
<DT><B>POLLERR</B>

<DD>
Error condition (only returned in
<I>revents</I>;

ignored in
<I>events</I>).

This bit is also set for a file descriptor referring
to the write end of a pipe when the read end has been closed.
<DT><B>POLLHUP</B>

<DD>
Hang up (only returned in
<I>revents</I>;

ignored in
<I>events</I>).

Note that when reading from a channel such as a pipe or a stream socket,
this event merely indicates that the peer closed its end of the channel.
Subsequent reads from the channel will return 0 (end of file)
only after all outstanding data in the channel has been consumed.
<DT><B>POLLNVAL</B>

<DD>
Invalid request:
<I>fd</I>

not open (only returned in
<I>revents</I>;

ignored in
<I>events</I>).

</DL>
<P>

When compiling with
<B>_XOPEN_SOURCE</B>

defined, one also has the following,
which convey no further information beyond the bits listed above:
<DL COMPACT>
<DT><B>POLLRDNORM</B>

<DD>
Equivalent to
<B>POLLIN</B>.

<DT><B>POLLRDBAND</B>

<DD>
Priority band data can be read (generally unused on Linux).

<DT><B>POLLWRNORM</B>

<DD>
Equivalent to
<B>POLLOUT</B>.

<DT><B>POLLWRBAND</B>

<DD>
Priority data may be written.
</DL>
<P>

Linux also knows about, but does not use
<B>POLLMSG</B>.

<A NAME="lbAE">&nbsp;</A>
<H3>ppoll()</H3>

The relationship between
<B>poll</B>()

and
<B>ppoll</B>()

is analogous to the relationship between
<B><A HREF="../man2/select.2.html">select</A></B>(2)

and
<B><A HREF="../man2/pselect.2.html">pselect</A></B>(2):

like
<B><A HREF="../man2/pselect.2.html">pselect</A></B>(2),

<B>ppoll</B>()

allows an application to safely wait until either a file descriptor
becomes ready or until a signal is caught.
<P>

Other than the difference in the precision of the
<I>timeout</I>

argument, the following
<B>ppoll</B>()

call:
<P>



ready = ppoll(&amp;fds, nfds, tmo_p, &amp;sigmask);


<P>

is nearly equivalent to
<I>atomically</I>

executing the following calls:
<P>



sigset_t origmask;
int timeout;
<P>
timeout = (tmo_p == NULL) ? -1 :
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(tmo_p-&gt;tv_sec&nbsp;*&nbsp;1000&nbsp;+&nbsp;tmo_p-&gt;tv_nsec&nbsp;/&nbsp;1000000);
pthread_sigmask(SIG_SETMASK, &amp;sigmask, &amp;origmask);
ready = poll(&amp;fds, nfds, timeout);
pthread_sigmask(SIG_SETMASK, &amp;origmask, NULL);


<P>

The above code segment is described as
<I>nearly</I>

equivalent because whereas a negative
<I>timeout</I>

value for
<B>poll</B>()

is interpreted as an infinite timeout, a negative value expressed in
<I>*tmo_p</I>

results in an error from
<B>ppoll</B>().

<P>

See the description of
<B><A HREF="../man2/pselect.2.html">pselect</A></B>(2)

for an explanation of why
<B>ppoll</B>()

is necessary.
<P>

If the
<I>sigmask</I>

argument is specified as NULL, then
no signal mask manipulation is performed
(and thus
<B>ppoll</B>()

differs from
<B>poll</B>()

only in the precision of the
<I>timeout</I>

argument).
<P>

The
<I>tmo_p</I>

argument specifies an upper limit on the amount of time that
<B>ppoll</B>()

will block.
This argument is a pointer to a structure of the following form:
<P>



struct timespec {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;&nbsp;&nbsp;&nbsp;tv_sec;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;seconds&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;&nbsp;&nbsp;&nbsp;tv_nsec;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;nanoseconds&nbsp;*/
};


<P>

If
<I>tmo_p</I>

is specified as NULL, then
<B>ppoll</B>()

can block indefinitely.
<A NAME="lbAF">&nbsp;</A>
<H2>RETURN VALUE</H2>

On success,
<B>poll</B>()

returns a nonnegative value which is the number of elements in the
<I>pollfds</I>

whose
<I>revents</I>

fields have been set to a nonzero value (indicating an event or an error).
A return value of zero indicates that the system call timed out
before any file descriptors became read.
<P>

On error, -1 is returned, and
<I>errno</I>

is set to indicate the cause of the error.
<A NAME="lbAG">&nbsp;</A>
<H2>ERRORS</H2>

<DL COMPACT>
<DT><B>EFAULT</B>

<DD>
<I>fds</I>

points outside the process's accessible address space.
The array given as argument was not contained in the calling program's
address space.
<DT><B>EINTR</B>

<DD>
A signal occurred before any requested event; see
<B><A HREF="../man7/signal.7.html">signal</A></B>(7).

<DT><B>EINVAL</B>

<DD>
The
<I>nfds</I>

value exceeds the
<B>RLIMIT_NOFILE</B>

value.
<DT><B>EINVAL</B>

<DD>
(<B>ppoll</B>())

The timeout value expressed in
<I>*ip</I>

is invalid (negative).
<DT><B>ENOMEM</B>

<DD>
Unable to allocate memory for kernel data structures.
</DL>
<A NAME="lbAH">&nbsp;</A>
<H2>VERSIONS</H2>

The
<B>poll</B>()

system call was introduced in Linux 2.1.23.
On older kernels that lack this system call,
the glibc
<B>poll</B>()

wrapper function provides emulation using
<B><A HREF="../man2/select.2.html">select</A></B>(2).

<P>

The
<B>ppoll</B>()

system call was added to Linux in kernel 2.6.16.
The
<B>ppoll</B>()

library call was added in glibc 2.4.
<A NAME="lbAI">&nbsp;</A>
<H2>CONFORMING TO</H2>

<B>poll</B>()

conforms to POSIX.1-2001 and POSIX.1-2008.
<B>ppoll</B>()

is Linux-specific.

<A NAME="lbAJ">&nbsp;</A>
<H2>NOTES</H2>

The operation of
<B>poll</B>()

and
<B>ppoll</B>()

is not affected by the
<B>O_NONBLOCK</B>

flag.
<P>

On some other UNIX systems,

<B>poll</B>()

can fail with the error
<B>EAGAIN</B>

if the system fails to allocate kernel-internal resources, rather than
<B>ENOMEM</B>

as Linux does.
POSIX permits this behavior.
Portable programs may wish to check for
<B>EAGAIN</B>

and loop, just as with
<B>EINTR</B>.

<P>

Some implementations define the nonstandard constant
<B>INFTIM</B>

with the value -1 for use as a
<I>timeout</I>

for
<B>poll</B>().

This constant is not provided in glibc.
<P>

For a discussion of what may happen if a file descriptor being monitored by
<B>poll</B>()

is closed in another thread, see
<B><A HREF="../man2/select.2.html">select</A></B>(2).

<A NAME="lbAK">&nbsp;</A>
<H3>C library/kernel differences</H3>

The Linux
<B>ppoll</B>()

system call modifies its
<I>tmo_p</I>

argument.
However, the glibc wrapper function hides this behavior
by using a local variable for the timeout argument that
is passed to the system call.
Thus, the glibc
<B>ppoll</B>()

function does not modify its
<I>tmo_p</I>

argument.
<P>

The raw
<B>ppoll</B>()

system call has a fifth argument,
<I>size_t sigsetsize</I>,

which specifies the size in bytes of the
<I>sigmask</I>

argument.
The glibc
<B>ppoll</B>()

wrapper function specifies this argument as a fixed value
(equal to
<I>sizeof(kernel_sigset_t)</I>).

See
<B><A HREF="../man2/sigprocmask.2.html">sigprocmask</A></B>(2)

for a discussion on the differences between the kernel and the libc
notion of the sigset.
<A NAME="lbAL">&nbsp;</A>
<H2>BUGS</H2>

See the discussion of spurious readiness notifications under the
BUGS section of
<B><A HREF="../man2/select.2.html">select</A></B>(2).

<A NAME="lbAM">&nbsp;</A>
<H2>EXAMPLE</H2>

The program below opens each of the files named in its command-line
arguments and monitors the resulting file descriptors for readiness to read
(<B>POLLIN</B>).

The program loops, repeatedly using
<B>poll</B>()

to monitor the file descriptors,
printing the number of ready file descriptors on return.
For each ready file descriptor, the program:
<DL COMPACT>
<DT>&bull;<DD>
displays the returned
<I>revents</I>

field in a human-readable form;
<DT>&bull;<DD>
if the file descriptor is readable, reads some data from it,
and displays that data on standard output; and
<DT>&bull;<DD>
if the file descriptors was not readable,
but some other event occurred (presumably
<B>POLLHUP</B>),

closes the file descriptor.
</DL>
<P>

Suppose we run the program in one terminal, asking it to open a FIFO:
<P>



$ <B>mkfifo myfifo</B>
$ <B>./poll_input myfifo</B>


<P>

In a second terminal window, we then open the FIFO for writing,
write some data to it, and close the FIFO:
<P>



$ <B>echo aaaaabbbbbccccc &gt; myfifo</B>


<P>

In the terminal where we are running the program, we would then see:
<P>



Opened &quot;myfifo&quot; on fd 3
About to poll()
Ready: 1
<BR>&nbsp;&nbsp;fd=3;&nbsp;events:&nbsp;POLLIN&nbsp;POLLHUP
<BR>&nbsp;&nbsp;&nbsp;&nbsp;read&nbsp;10&nbsp;bytes:&nbsp;aaaaabbbbb
About to poll()
Ready: 1
<BR>&nbsp;&nbsp;fd=3;&nbsp;events:&nbsp;POLLIN&nbsp;POLLHUP
<BR>&nbsp;&nbsp;&nbsp;&nbsp;read&nbsp;6&nbsp;bytes:&nbsp;ccccc
<P>
About to poll()
Ready: 1
<BR>&nbsp;&nbsp;fd=3;&nbsp;events:&nbsp;POLLHUP
<BR>&nbsp;&nbsp;&nbsp;&nbsp;closing&nbsp;fd&nbsp;3
All file descriptors closed; bye


<P>

In the above output, we see that
<B>poll</B>()

returned three times:
<DL COMPACT>
<DT>&bull;<DD>
On the first return, the bits returned in the
<I>revents</I>

field were
<B>POLLIN</B>,

indicating that the file descriptor is readable, and
<B>POLLHUP</B>,

indicating that the other end of the FIFO has been closed.
The program then consumed some of the available input.
<DT>&bull;<DD>
The second return from
<B>poll</B>()

also indicated
<B>POLLIN</B>

and
<B>POLLHUP</B>;

the program then consumed the last of the available input.
<DT>&bull;<DD>
On the final return,
<B>poll</B>()

indicated only
<B>POLLHUP</B>

on the FIFO,
at which point the file descriptor was closed and the program terminated.

</DL>
<A NAME="lbAN">&nbsp;</A>
<H3>Program source</H3>


<PRE>
/* poll_input.c */

#include &lt;<A HREF="file:///usr/include/poll.h">poll.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/fcntl.h">fcntl.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/sys/types.h">sys/types.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/stdio.h">stdio.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/stdlib.h">stdlib.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;

#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
                        } while (0)

int
main(int argc, char *argv[])
{
    int nfds, num_open_fds;
    struct pollfd *pfds;

    if (argc &lt; 2) {
       fprintf(stderr, &quot;Usage: %s file...\n&quot;, argv[0]);
       exit(EXIT_FAILURE);
    }

    num_open_fds = nfds = argc - 1;
    pfds = calloc(nfds, sizeof(struct pollfd));
    if (pfds == NULL)
        errExit(&quot;malloc&quot;);

    /* Open each file on command line, and add it 'pfds' array */

    for (int j = 0; j &lt; nfds; j++) {
        pfds[j].fd = open(argv[j + 1], O_RDONLY);
        if (pfds[j].fd == -1)
            errExit(&quot;open&quot;);

        printf(&quot;Opened \&quot;%s\&quot; on fd %d\n&quot;, argv[j + 1], pfds[j].fd);

        pfds[j].events = POLLIN;
    }

    /* Keep calling poll() as long as at least one file descriptor is
       open */

    while (num_open_fds &gt; 0) {
        int ready;

        printf(&quot;About to poll()\n&quot;);
        ready = poll(pfds, nfds, -1);
        if (ready == -1)
            errExit(&quot;poll&quot;);

        printf(&quot;Ready: %d\n&quot;, ready);

        /* Deal with array returned by poll() */

        for (int j = 0; j &lt; nfds; j++) {
            char buf[10];

            if (pfds[j].revents != 0) {
                printf(&quot;  fd=%d; events: %s%s%s\n&quot;, pfds[j].fd,
                        (pfds[j].revents &amp; POLLIN)  ? &quot;POLLIN &quot;  : &quot;&quot;,
                        (pfds[j].revents &amp; POLLHUP) ? &quot;POLLHUP &quot; : &quot;&quot;,
                        (pfds[j].revents &amp; POLLERR) ? &quot;POLLERR &quot; : &quot;&quot;);

                if (pfds[j].revents &amp; POLLIN) {
                    ssize_t s = read(pfds[j].fd, buf, sizeof(buf));
                    if (s == -1)
                        errExit(&quot;read&quot;);
                    printf(&quot;    read %zd bytes: %.*s\n&quot;,
                            s, (int) s, buf);
                } else {                /* POLLERR | POLLHUP */
                    printf(&quot;    closing fd %d\n&quot;, pfds[j].fd);
                    if (close(pfds[j].fd) == -1)
                        errExit(&quot;close&quot;);
                    num_open_fds--;
                }
            }
        }
    }

    printf(&quot;All file descriptors closed; bye\n&quot;);
    exit(EXIT_SUCCESS);
}
</PRE>

<A NAME="lbAO">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="../man2/restart_syscall.2.html">restart_syscall</A></B>(2),

<B><A HREF="../man2/select.2.html">select</A></B>(2),

<B><A HREF="../man2/select_tut.2.html">select_tut</A></B>(2),

<B><A HREF="../man7/epoll.7.html">epoll</A></B>(7),

<B><A HREF="../man7/time.7.html">time</A></B>(7)

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE">ppoll()</A><DD>
</DL>
<DT><A HREF="#lbAF">RETURN VALUE</A><DD>
<DT><A HREF="#lbAG">ERRORS</A><DD>
<DT><A HREF="#lbAH">VERSIONS</A><DD>
<DT><A HREF="#lbAI">CONFORMING TO</A><DD>
<DT><A HREF="#lbAJ">NOTES</A><DD>
<DL>
<DT><A HREF="#lbAK">C library/kernel differences</A><DD>
</DL>
<DT><A HREF="#lbAL">BUGS</A><DD>
<DT><A HREF="#lbAM">EXAMPLE</A><DD>
<DL>
<DT><A HREF="#lbAN">Program source</A><DD>
</DL>
<DT><A HREF="#lbAO">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 03:53:21 GMT, April 20, 2020
</BODY>
</HTML>
