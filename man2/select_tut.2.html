<!--
%%%LICENSE_START(VERBATIM)
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
.\"
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.
.\"
Since the Linux kernel and libraries are constantly changing, this
manual page may be incorrect or out-of-date.  The author(s) assume no
responsibility for errors or omissions, or for damages resulting from
the use of the information contained herein.  The author(s) may not
have taken the same level of care in the production of this manual,
which is licensed free of charge, as they might when working
professionally.
.\"
Formatted or processed versions of this manual, if unaccompanied by
the source, must acknowledge the copyright and authors of this work.
%%%LICENSE_END
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of SELECT_TUT</TITLE>
</HEAD><BODY>
<H1>SELECT_TUT</H1>
Section: Linux Programmer's Manual (2)<BR>Updated: 2019-03-06<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

select, pselect, FD_CLR, FD_ISSET, FD_SET, FD_ZERO -
synchronous I/O multiplexing
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<PRE>
/* According to POSIX.1-2001, POSIX.1-2008 */
<B>#include &lt;<A HREF="file:///usr/include/sys/select.h">sys/select.h</A>&gt;</B>

/* According to earlier standards */
<B>#include &lt;<A HREF="file:///usr/include/sys/time.h">sys/time.h</A>&gt;</B>
<B>#include &lt;<A HREF="file:///usr/include/sys/types.h">sys/types.h</A>&gt;</B>
<B>#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;</B>

<B>int select(int </B><I>nfds</I><B>, fd_set *</B><I>readfds</I><B>, fd_set *</B><I>writefds</I><B>,</B>
<B>           fd_set *</B><I>exceptfds</I><B>, struct timeval *</B><I>utimeout</I><B>);</B>

<B>void FD_CLR(int </B><I>fd</I><B>, fd_set *</B><I>set</I><B>);</B>
<B>int  FD_ISSET(int </B><I>fd</I><B>, fd_set *</B><I>set</I><B>);</B>
<B>void FD_SET(int </B><I>fd</I><B>, fd_set *</B><I>set</I><B>);</B>
<B>void FD_ZERO(fd_set *</B><I>set</I><B>);</B>

<B>#include &lt;<A HREF="file:///usr/include/sys/select.h">sys/select.h</A>&gt;</B>

<B>int pselect(int </B><I>nfds</I><B>, fd_set *</B><I>readfds</I><B>, fd_set *</B><I>writefds</I><B>,</B>
<B>            fd_set *</B><I>exceptfds</I><B>, const struct timespec *</B><I>ntimeout</I><B>,</B>
<B>            const sigset_t *</B><I>sigmask</I><B>);</B>
</PRE>

<P>


Feature Test Macro Requirements for glibc (see
<B><A HREF="../man7/feature_test_macros.7.html">feature_test_macros</A></B>(7)):


<P>

<B>pselect</B>():

_POSIX_C_SOURCE&nbsp;&gt;=&nbsp;200112L
<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<B>select</B>()

(or
<B>pselect</B>())

is used to efficiently monitor multiple file descriptors,
to see if any of them is, or becomes, &quot;ready&quot;;
that is, to see whether I/O becomes possible,
or an &quot;exceptional condition&quot; has occurred on any of the file descriptors.
<P>

Its principal arguments are three &quot;sets&quot; of file descriptors:
<I>readfds</I>, <I>writefds</I>, and <I>exceptfds</I>.
Each set is declared as type
<I>fd_set</I>,

and its contents can be manipulated with the macros
<B>FD_CLR</B>(),

<B>FD_ISSET</B>(),

<B>FD_SET</B>(),

and
<B>FD_ZERO</B>().

A newly declared set should first be cleared using
<B>FD_ZERO</B>().

<B>select</B>()

modifies the contents of the sets according to the rules
described below; after calling
<B>select</B>()

you can test if a file descriptor is still present in a set with the
<B>FD_ISSET</B>()

macro.
<B>FD_ISSET</B>()

returns nonzero if a specified file descriptor is present in a set
and zero if it is not.
<B>FD_CLR</B>()

removes a file descriptor from a set.
<A NAME="lbAE">&nbsp;</A>
<H3>Arguments</H3>

<DL COMPACT>
<DT><I>readfds</I><DD>
This set is watched to see if data is available for reading from any of
its file descriptors.
After
<B>select</B>()

has returned, <I>readfds</I> will be
cleared of all file descriptors except for those that
are immediately available for reading.
<DT><I>writefds</I><DD>
This set is watched to see if there is space to write data to any of
its file descriptors.
After
<B>select</B>()

has returned, <I>writefds</I> will be
cleared of all file descriptors except for those that
are immediately available for writing.
<DT><I>exceptfds</I><DD>
This set is watched for &quot;exceptional conditions&quot;.
In practice, only one such exceptional condition is common:
the availability of <I>out-of-band</I> (OOB) data for reading
from a TCP socket.
See
<B><A HREF="../man2/recv.2.html">recv</A></B>(2),

<B><A HREF="../man2/send.2.html">send</A></B>(2),

and
<B><A HREF="../man7/tcp.7.html">tcp</A></B>(7)

for more details about OOB data.
(One other less common case where
<B><A HREF="../man2/select.2.html">select</A></B>(2)

indicates an exceptional condition occurs with pseudoterminals
in packet mode; see
<B><A HREF="../man2/ioctl_tty.2.html">ioctl_tty</A></B>(2).)

After
<B>select</B>()

has returned,
<I>exceptfds</I> will be cleared of all file descriptors except for those
for which an exceptional condition has occurred.
<DT><I>nfds</I><DD>
This is an integer one more than the maximum of any file descriptor in
any of the sets.
In other words, while adding file descriptors to each of the sets,
you must calculate the maximum integer value of all of them,
then increment this value by one, and then pass this as <I>nfds</I>.
<DT><I>utimeout</I><DD>
This is the longest time
<B>select</B>()

may wait before returning, even if nothing interesting happened.
If this value is passed as NULL, then
<B>select</B>()

blocks indefinitely waiting for a file descriptor to become ready.
<I>utimeout</I> can be set to zero seconds, which causes
<B>select</B>()

to return immediately, with information about the readiness
of file descriptors at the time of the call.
The structure <I>struct timeval</I> is defined as:
<DT><DD>


struct timeval {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;time_t&nbsp;tv_sec;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;seconds&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;tv_usec;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;microseconds&nbsp;*/
};


<DT><I>ntimeout</I><DD>
This argument for
<B>pselect</B>()

has the same meaning as
<I>utimeout</I>,

but
<I>struct timespec</I>

has nanosecond precision as follows:
<DT><DD>


struct timespec {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;tv_sec;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;seconds&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;long&nbsp;tv_nsec;&nbsp;&nbsp;&nbsp;/*&nbsp;nanoseconds&nbsp;*/
};


<DT><I>sigmask</I><DD>
This argument holds a set of signals that the kernel should unblock
(i.e., remove from the signal mask of the calling thread),
while the caller is blocked inside the
<B>pselect</B>()

call (see
<B><A HREF="../man3/sigaddset.3.html">sigaddset</A></B>(3)

and
<B><A HREF="../man2/sigprocmask.2.html">sigprocmask</A></B>(2)).

It may be NULL,
in which case the call does not modify the signal mask on
entry and exit to the function.
In this case,
<B>pselect</B>()

will then behave just like
<B>select</B>().

</DL>
<A NAME="lbAF">&nbsp;</A>
<H3>Combining signal and data events</H3>

<B>pselect</B>()

is useful if you are waiting for a signal as well as
for file descriptor(s) to become ready for I/O.
Programs that receive signals
normally use the signal handler only to raise a global flag.
The global flag will indicate that the event must be processed
in the main loop of the program.
A signal will cause the
<B>select</B>()

(or
<B>pselect</B>())

call to return with <I>errno</I> set to <B>EINTR</B>.
This behavior is essential so that signals can be processed
in the main loop of the program, otherwise
<B>select</B>()

would block indefinitely.
Now, somewhere
in the main loop will be a conditional to check the global flag.
So we must ask:
what if a signal arrives after the conditional, but before the
<B>select</B>()

call?
The answer is that
<B>select</B>()

would block indefinitely, even though an event is actually pending.
This race condition is solved by the
<B>pselect</B>()

call.
This call can be used to set the signal mask to a set of signals
that are to be received only within the
<B>pselect</B>()

call.
For instance, let us say that the event in question
was the exit of a child process.
Before the start of the main loop, we
would block <B>SIGCHLD</B> using
<B><A HREF="../man2/sigprocmask.2.html">sigprocmask</A></B>(2).

Our
<B>pselect</B>()

call would enable
<B>SIGCHLD</B>

by using an empty signal mask.
Our program would look like:
<P>


static volatile sig_atomic_t got_SIGCHLD = 0;
<P>
static void
child_sig_handler(int sig)
{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;got_SIGCHLD&nbsp;=&nbsp;1;
}
<P>
int
main(int argc, char *argv[])
{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;sigset_t&nbsp;sigmask,&nbsp;empty_mask;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;sigaction&nbsp;sa;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;fd_set&nbsp;readfds,&nbsp;writefds,&nbsp;exceptfds;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;r;
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;sigemptyset(&amp;sigmask);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;sigaddset(&amp;sigmask,&nbsp;SIGCHLD);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sigprocmask(SIG_BLOCK,&nbsp;&amp;sigmask,&nbsp;NULL)&nbsp;==&nbsp;-1)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror(&quot;sigprocmask&quot;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(EXIT_FAILURE);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;sa.sa_flags&nbsp;=&nbsp;0;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;sa.sa_handler&nbsp;=&nbsp;child_sig_handler;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;sigemptyset(&amp;sa.sa_mask);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sigaction(SIGCHLD,&nbsp;&amp;sa,&nbsp;NULL)&nbsp;==&nbsp;-1)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror(&quot;sigaction&quot;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(EXIT_FAILURE);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;sigemptyset(&amp;empty_mask);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;;)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;main&nbsp;loop&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Initialize&nbsp;readfds,&nbsp;writefds,&nbsp;and&nbsp;exceptfds
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;before&nbsp;the&nbsp;pselect()&nbsp;call.&nbsp;(Code&nbsp;omitted.)&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r&nbsp;=&nbsp;pselect(nfds,&nbsp;&amp;readfds,&nbsp;&amp;writefds,&nbsp;&amp;exceptfds,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NULL,&nbsp;&amp;empty_mask);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(r&nbsp;==&nbsp;-1&nbsp;&amp;&amp;&nbsp;errno&nbsp;!=&nbsp;EINTR)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Handle&nbsp;error&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(got_SIGCHLD)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;got_SIGCHLD&nbsp;=&nbsp;0;
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Handle&nbsp;signalled&nbsp;event&nbsp;here;&nbsp;e.g.,&nbsp;wait()&nbsp;for&nbsp;all
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;terminated&nbsp;children.&nbsp;(Code&nbsp;omitted.)&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;main&nbsp;body&nbsp;of&nbsp;program&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;}
}

<A NAME="lbAG">&nbsp;</A>
<H3>Practical</H3>

So what is the point of
<B>select</B>()?

Can't I just read and write to my file descriptors whenever I want?
The point of
<B>select</B>()

is that it watches
multiple descriptors at the same time and properly puts the process to
sleep if there is no activity.
UNIX programmers often find
themselves in a position where they have to handle I/O from more than one
file descriptor where the data flow may be intermittent.
If you were to merely create a sequence of
<B><A HREF="../man2/read.2.html">read</A></B>(2)

and
<B><A HREF="../man2/write.2.html">write</A></B>(2)

calls, you would
find that one of your calls may block waiting for data from/to a file
descriptor, while another file descriptor is unused though ready for I/O.
<B>select</B>()

efficiently copes with this situation.
<A NAME="lbAH">&nbsp;</A>
<H3>Select law</H3>

Many people who try to use
<B>select</B>()

come across behavior that is
difficult to understand and produces nonportable or borderline results.
For instance, the above program is carefully written not to
block at any point, even though it does not set its file descriptors to
nonblocking mode.
It is easy to introduce
subtle errors that will remove the advantage of using
<B>select</B>(),

so here is a list of essentials to watch for when using
<B>select</B>().

<DL COMPACT>
<DT>1.<DD>
You should always try to use
<B>select</B>()

without a timeout.
Your program
should have nothing to do if there is no data available.
Code that
depends on timeouts is not usually portable and is difficult to debug.
<DT>2.<DD>
The value <I>nfds</I> must be properly calculated for efficiency as
explained above.
<DT>3.<DD>
No file descriptor must be added to any set if you do not intend
to check its result after the
<B>select</B>()

call, and respond appropriately.
See next rule.
<DT>4.<DD>
After
<B>select</B>()

returns, all file descriptors in all sets
should be checked to see if they are ready.
<DT>5.<DD>
The functions
<B><A HREF="../man2/read.2.html">read</A></B>(2),

<B><A HREF="../man2/recv.2.html">recv</A></B>(2),

<B><A HREF="../man2/write.2.html">write</A></B>(2),

and
<B><A HREF="../man2/send.2.html">send</A></B>(2)

do <I>not</I> necessarily read/write the full amount of data
that you have requested.
If they do read/write the full amount, it's
because you have a low traffic load and a fast stream.
This is not always going to be the case.
You should cope with the case of your
functions managing to send or receive only a single byte.
<DT>6.<DD>
Never read/write only in single bytes at a time unless you are really
sure that you have a small amount of data to process.
It is extremely
inefficient not to read/write as much data as you can buffer each time.
The buffers in the example below are 1024 bytes although they could
easily be made larger.
<DT>7.<DD>
Calls to
<B><A HREF="../man2/read.2.html">read</A></B>(2),

<B><A HREF="../man2/recv.2.html">recv</A></B>(2),

<B><A HREF="../man2/write.2.html">write</A></B>(2),

<B><A HREF="../man2/send.2.html">send</A></B>(2),

and
<B>select</B>()

can fail with the error
<B>EINTR</B>,
and calls to
<B><A HREF="../man2/read.2.html">read</A></B>(2),

<B><A HREF="../man2/recv.2.html">recv</A></B>(2)

<B><A HREF="../man2/write.2.html">write</A></B>(2),

and
<B><A HREF="../man2/send.2.html">send</A></B>(2)

can fail with
<I>errno</I>

set to <B>EAGAIN</B> (<B>EWOULDBLOCK</B>).
These results must be properly managed (not done properly above).
If your program is not going to receive any signals, then
it is unlikely you will get <B>EINTR</B>.
If your program does not set nonblocking I/O,
you will not get <B>EAGAIN</B>.

<DT>8.<DD>
Never call
<B><A HREF="../man2/read.2.html">read</A></B>(2),

<B><A HREF="../man2/recv.2.html">recv</A></B>(2),

<B><A HREF="../man2/write.2.html">write</A></B>(2),

or
<B><A HREF="../man2/send.2.html">send</A></B>(2)

with a buffer length of zero.
<DT>9.<DD>
If the functions
<B><A HREF="../man2/read.2.html">read</A></B>(2),

<B><A HREF="../man2/recv.2.html">recv</A></B>(2),

<B><A HREF="../man2/write.2.html">write</A></B>(2),

and
<B><A HREF="../man2/send.2.html">send</A></B>(2)

fail with errors other than those listed in <B>7.</B>,
or one of the input functions returns 0, indicating end of file,
then you should <I>not</I> pass that file descriptor to
<B>select</B>()

again.
In the example below,
I close the file descriptor immediately, and then set it to -1
to prevent it being included in a set.
<DT>10.<DD>
The timeout value must be initialized with each new call to
<B>select</B>(),

since some operating systems modify the structure.
<B>pselect</B>()

however does not modify its timeout structure.
<DT>11.<DD>
Since
<B>select</B>()

modifies its file descriptor sets,
if the call is being used in a loop,
then the sets must be reinitialized before each call.












</DL>
<A NAME="lbAI">&nbsp;</A>
<H3>Usleep emulation</H3>

On systems that do not have a
<B><A HREF="../man3/usleep.3.html">usleep</A></B>(3)

function, you can call
<B>select</B>()

with a finite timeout and no file descriptors as
follows:
<P>



struct timeval tv;
tv.tv_sec = 0;
tv.tv_usec = 200000;  /* 0.2 seconds */
select(0, NULL, NULL, NULL, &amp;tv);


<P>

This is guaranteed to work only on UNIX systems, however.
<A NAME="lbAJ">&nbsp;</A>
<H2>RETURN VALUE</H2>

On success,
<B>select</B>()

returns the total number of file descriptors
still present in the file descriptor sets.
<P>

If
<B>select</B>()

timed out, then the return value will be zero.
The file descriptors set should be all
empty (but may not be on some systems).
<P>

A return value of -1 indicates an error, with <I>errno</I> being
set appropriately.
In the case of an error, the contents of the returned sets and
the <I>struct timeout</I> contents are undefined and should not be used.
<B>pselect</B>()

however never modifies <I>ntimeout</I>.
<A NAME="lbAK">&nbsp;</A>
<H2>NOTES</H2>

Generally speaking,
all operating systems that support sockets also support
<B>select</B>().

<B>select</B>()

can be used to solve
many problems in a portable and efficient way that naive programmers try
to solve in a more complicated manner using
threads, forking, IPCs, signals, memory sharing, and so on.
<P>

The
<B><A HREF="../man2/poll.2.html">poll</A></B>(2)

system call has the same functionality as
<B>select</B>(),

and is somewhat more efficient when monitoring sparse
file descriptor sets.
It is nowadays widely available, but historically was less portable than
<B>select</B>().

<P>

The Linux-specific
<B><A HREF="../man7/epoll.7.html">epoll</A></B>(7)

API provides an interface that is more efficient than
<B><A HREF="../man2/select.2.html">select</A></B>(2)

and
<B><A HREF="../man2/poll.2.html">poll</A></B>(2)

when monitoring large numbers of file descriptors.
<A NAME="lbAL">&nbsp;</A>
<H2>EXAMPLE</H2>

Here is an example that better demonstrates the true utility of
<B>select</B>().

The listing below is a TCP forwarding program that forwards
from one TCP port to another.
<P>


#include &lt;<A HREF="file:///usr/include/stdlib.h">stdlib.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/stdio.h">stdio.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/sys/time.h">sys/time.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/sys/types.h">sys/types.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/string.h">string.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/signal.h">signal.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/sys/socket.h">sys/socket.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/netinet/in.h">netinet/in.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/arpa/inet.h">arpa/inet.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/errno.h">errno.h</A>&gt;
<P>
static int forward_port;
<P>
#undef max
#define max(x,y) ((x) &gt; (y) ? (x) : (y))
<P>
static int
listen_socket(int listen_port)
{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;sockaddr_in&nbsp;addr;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;lfd;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;yes;
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;lfd&nbsp;=&nbsp;socket(AF_INET,&nbsp;SOCK_STREAM,&nbsp;0);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(lfd&nbsp;==&nbsp;-1)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror(&quot;socket&quot;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;yes&nbsp;=&nbsp;1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(setsockopt(lfd,&nbsp;SOL_SOCKET,&nbsp;SO_REUSEADDR,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&amp;yes,&nbsp;sizeof(yes))&nbsp;==&nbsp;-1)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror(&quot;setsockopt&quot;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(lfd);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;memset(&amp;addr,&nbsp;0,&nbsp;sizeof(addr));
<BR>&nbsp;&nbsp;&nbsp;&nbsp;addr.sin_port&nbsp;=&nbsp;htons(listen_port);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;addr.sin_family&nbsp;=&nbsp;AF_INET;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(bind(lfd,&nbsp;(struct&nbsp;sockaddr&nbsp;*)&nbsp;&amp;addr,&nbsp;sizeof(addr))&nbsp;==&nbsp;-1)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror(&quot;bind&quot;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(lfd);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;accepting&nbsp;connections&nbsp;on&nbsp;port&nbsp;%d\n&quot;,&nbsp;listen_port);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;listen(lfd,&nbsp;10);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;lfd;
}
<P>
static int
connect_socket(int connect_port, char *address)
{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;sockaddr_in&nbsp;addr;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;cfd;
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;cfd&nbsp;=&nbsp;socket(AF_INET,&nbsp;SOCK_STREAM,&nbsp;0);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(cfd&nbsp;==&nbsp;-1)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror(&quot;socket&quot;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;memset(&amp;addr,&nbsp;0,&nbsp;sizeof(addr));
<BR>&nbsp;&nbsp;&nbsp;&nbsp;addr.sin_port&nbsp;=&nbsp;htons(connect_port);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;addr.sin_family&nbsp;=&nbsp;AF_INET;
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(!inet_aton(address,&nbsp;(struct&nbsp;in_addr&nbsp;*)&nbsp;&amp;addr.sin_addr.s_addr))&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;&quot;inet_aton():&nbsp;bad&nbsp;IP&nbsp;address&nbsp;format\n&quot;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(cfd);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(connect(cfd,&nbsp;(struct&nbsp;sockaddr&nbsp;*)&nbsp;&amp;addr,&nbsp;sizeof(addr))&nbsp;==&nbsp;-1)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror(&quot;connect()&quot;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shutdown(cfd,&nbsp;SHUT_RDWR);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(cfd);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;cfd;
}
<P>
#define SHUT_FD1 do {                                \
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd1&nbsp;&gt;=&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shutdown(fd1,&nbsp;SHUT_RDWR);&nbsp;&nbsp;&nbsp;\
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(fd1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fd1&nbsp;=&nbsp;-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;while&nbsp;(0)
<P>
#define SHUT_FD2 do {                                \
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd2&nbsp;&gt;=&nbsp;0)&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shutdown(fd2,&nbsp;SHUT_RDWR);&nbsp;&nbsp;&nbsp;\
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;close(fd2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fd2&nbsp;=&nbsp;-1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;while&nbsp;(0)
<P>
#define BUF_SIZE 1024
<P>
int
main(int argc, char *argv[])
{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;h;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;fd1&nbsp;=&nbsp;-1,&nbsp;fd2&nbsp;=&nbsp;-1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;buf1[BUF_SIZE],&nbsp;buf2[BUF_SIZE];
<BR>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;buf1_avail&nbsp;=&nbsp;0,&nbsp;buf1_written&nbsp;=&nbsp;0;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;buf2_avail&nbsp;=&nbsp;0,&nbsp;buf2_written&nbsp;=&nbsp;0;
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;!=&nbsp;4)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;&quot;Usage\n\tfwd&nbsp;&lt;listen-port&gt;&nbsp;&quot;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&quot;&lt;forward-to-port&gt;&nbsp;&lt;forward-to-ip-address&gt;\n&quot;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(EXIT_FAILURE);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;signal(SIGPIPE,&nbsp;SIG_IGN);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;forward_port&nbsp;=&nbsp;atoi(argv[2]);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;h&nbsp;=&nbsp;listen_socket(atoi(argv[1]));
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(h&nbsp;==&nbsp;-1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(EXIT_FAILURE);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(;;)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;ready,&nbsp;nfds&nbsp;=&nbsp;0;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ssize_t&nbsp;nbytes;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fd_set&nbsp;readfds,&nbsp;writefds,&nbsp;exceptfds;
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_ZERO(&amp;readfds);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_ZERO(&amp;writefds);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_ZERO(&amp;exceptfds);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_SET(h,&nbsp;&amp;readfds);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nfds&nbsp;=&nbsp;max(nfds,&nbsp;h);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd1&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;buf1_avail&nbsp;&lt;&nbsp;BUF_SIZE)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_SET(fd1,&nbsp;&amp;readfds);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Note:&nbsp;nfds&nbsp;is&nbsp;updated&nbsp;below,&nbsp;when&nbsp;fd1&nbsp;is&nbsp;added&nbsp;to
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exceptfds.&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd2&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;buf2_avail&nbsp;&lt;&nbsp;BUF_SIZE)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_SET(fd2,&nbsp;&amp;readfds);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd1&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;buf2_avail&nbsp;-&nbsp;buf2_written&nbsp;&gt;&nbsp;0)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_SET(fd1,&nbsp;&amp;writefds);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd2&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;buf1_avail&nbsp;-&nbsp;buf1_written&nbsp;&gt;&nbsp;0)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_SET(fd2,&nbsp;&amp;writefds);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd1&nbsp;&gt;&nbsp;0)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_SET(fd1,&nbsp;&amp;exceptfds);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nfds&nbsp;=&nbsp;max(nfds,&nbsp;fd1);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd2&nbsp;&gt;&nbsp;0)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FD_SET(fd2,&nbsp;&amp;exceptfds);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nfds&nbsp;=&nbsp;max(nfds,&nbsp;fd2);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ready&nbsp;=&nbsp;select(nfds&nbsp;+&nbsp;1,&nbsp;&amp;readfds,&nbsp;&amp;writefds,&nbsp;&amp;exceptfds,&nbsp;NULL);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ready&nbsp;==&nbsp;-1&nbsp;&amp;&amp;&nbsp;errno&nbsp;==&nbsp;EINTR)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ready&nbsp;==&nbsp;-1)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror(&quot;select()&quot;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(EXIT_FAILURE);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(FD_ISSET(h,&nbsp;&amp;readfds))&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;socklen_t&nbsp;addrlen;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;sockaddr_in&nbsp;client_addr;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;fd;
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addrlen&nbsp;=&nbsp;sizeof(client_addr);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;memset(&amp;client_addr,&nbsp;0,&nbsp;addrlen);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fd&nbsp;=&nbsp;accept(h,&nbsp;(struct&nbsp;sockaddr&nbsp;*)&nbsp;&amp;client_addr,&nbsp;&amp;addrlen);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd&nbsp;==&nbsp;-1)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;perror(&quot;accept()&quot;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;else&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHUT_FD1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHUT_FD2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf1_avail&nbsp;=&nbsp;buf1_written&nbsp;=&nbsp;0;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf2_avail&nbsp;=&nbsp;buf2_written&nbsp;=&nbsp;0;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fd1&nbsp;=&nbsp;fd;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fd2&nbsp;=&nbsp;connect_socket(forward_port,&nbsp;argv[3]);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd2&nbsp;==&nbsp;-1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHUT_FD1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&quot;connect&nbsp;from&nbsp;%s\n&quot;,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inet_ntoa(client_addr.sin_addr));
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Skip&nbsp;any&nbsp;events&nbsp;on&nbsp;the&nbsp;old,&nbsp;closed&nbsp;file&nbsp;descriptors.&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;continue;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;NB:&nbsp;read&nbsp;OOB&nbsp;data&nbsp;before&nbsp;normal&nbsp;reads&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd1&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;FD_ISSET(fd1,&nbsp;&amp;exceptfds))&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;c;
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nbytes&nbsp;=&nbsp;recv(fd1,&nbsp;&amp;c,&nbsp;1,&nbsp;MSG_OOB);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nbytes&nbsp;&lt;&nbsp;1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHUT_FD1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send(fd2,&nbsp;&amp;c,&nbsp;1,&nbsp;MSG_OOB);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd2&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;FD_ISSET(fd2,&nbsp;&amp;exceptfds))&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;c;
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nbytes&nbsp;=&nbsp;recv(fd2,&nbsp;&amp;c,&nbsp;1,&nbsp;MSG_OOB);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nbytes&nbsp;&lt;&nbsp;1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHUT_FD2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;send(fd1,&nbsp;&amp;c,&nbsp;1,&nbsp;MSG_OOB);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd1&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;FD_ISSET(fd1,&nbsp;&amp;readfds))&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nbytes&nbsp;=&nbsp;read(fd1,&nbsp;buf1&nbsp;+&nbsp;buf1_avail,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BUF_SIZE&nbsp;-&nbsp;buf1_avail);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nbytes&nbsp;&lt;&nbsp;1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHUT_FD1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf1_avail&nbsp;+=&nbsp;nbytes;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd2&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;FD_ISSET(fd2,&nbsp;&amp;readfds))&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nbytes&nbsp;=&nbsp;read(fd2,&nbsp;buf2&nbsp;+&nbsp;buf2_avail,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BUF_SIZE&nbsp;-&nbsp;buf2_avail);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nbytes&nbsp;&lt;&nbsp;1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHUT_FD2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf2_avail&nbsp;+=&nbsp;nbytes;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd1&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;FD_ISSET(fd1,&nbsp;&amp;writefds)&nbsp;&amp;&amp;&nbsp;buf2_avail&nbsp;&gt;&nbsp;0)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nbytes&nbsp;=&nbsp;write(fd1,&nbsp;buf2&nbsp;+&nbsp;buf2_written,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf2_avail&nbsp;-&nbsp;buf2_written);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nbytes&nbsp;&lt;&nbsp;1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHUT_FD1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf2_written&nbsp;+=&nbsp;nbytes;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd2&nbsp;&gt;&nbsp;0&nbsp;&amp;&amp;&nbsp;FD_ISSET(fd2,&nbsp;&amp;writefds)&nbsp;&amp;&amp;&nbsp;buf1_avail&nbsp;&gt;&nbsp;0)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nbytes&nbsp;=&nbsp;write(fd2,&nbsp;buf1&nbsp;+&nbsp;buf1_written,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf1_avail&nbsp;-&nbsp;buf1_written);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(nbytes&nbsp;&lt;&nbsp;1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHUT_FD2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf1_written&nbsp;+=&nbsp;nbytes;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Check&nbsp;if&nbsp;write&nbsp;data&nbsp;has&nbsp;caught&nbsp;read&nbsp;data&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf1_written&nbsp;==&nbsp;buf1_avail)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf1_written&nbsp;=&nbsp;buf1_avail&nbsp;=&nbsp;0;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(buf2_written&nbsp;==&nbsp;buf2_avail)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;buf2_written&nbsp;=&nbsp;buf2_avail&nbsp;=&nbsp;0;
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;One&nbsp;side&nbsp;has&nbsp;closed&nbsp;the&nbsp;connection,&nbsp;keep
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writing&nbsp;to&nbsp;the&nbsp;other&nbsp;side&nbsp;until&nbsp;empty&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd1&nbsp;&lt;&nbsp;0&nbsp;&amp;&amp;&nbsp;buf1_avail&nbsp;-&nbsp;buf1_written&nbsp;==&nbsp;0)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHUT_FD2;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd2&nbsp;&lt;&nbsp;0&nbsp;&amp;&amp;&nbsp;buf2_avail&nbsp;-&nbsp;buf2_written&nbsp;==&nbsp;0)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;SHUT_FD1;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;}
<BR>&nbsp;&nbsp;&nbsp;&nbsp;exit(EXIT_SUCCESS);
}

<P>

The above program properly forwards most kinds of TCP connections
including OOB signal data transmitted by <B>telnet</B> servers.
It handles the tricky problem of having data flow in both directions
simultaneously.
You might think it more efficient to use a
<B><A HREF="../man2/fork.2.html">fork</A></B>(2)

call and devote a thread to each stream.
This becomes more tricky than you might suspect.
Another idea is to set nonblocking I/O using
<B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2).

This also has its problems because you end up using
inefficient timeouts.
<P>

The program does not handle more than one simultaneous connection at a
time, although it could easily be extended to do this with a linked list
of buffers---one for each connection.
At the moment, new
connections cause the current connection to be dropped.
<A NAME="lbAM">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="../man2/accept.2.html">accept</A></B>(2),

<B><A HREF="../man2/connect.2.html">connect</A></B>(2),

<B><A HREF="../man2/ioctl.2.html">ioctl</A></B>(2),

<B><A HREF="../man2/poll.2.html">poll</A></B>(2),

<B><A HREF="../man2/read.2.html">read</A></B>(2),

<B><A HREF="../man2/recv.2.html">recv</A></B>(2),

<B><A HREF="../man2/select.2.html">select</A></B>(2),

<B><A HREF="../man2/send.2.html">send</A></B>(2),

<B><A HREF="../man2/sigprocmask.2.html">sigprocmask</A></B>(2),

<B><A HREF="../man2/write.2.html">write</A></B>(2),

<B><A HREF="../man3/sigaddset.3.html">sigaddset</A></B>(3),

<B><A HREF="../man3/sigdelset.3.html">sigdelset</A></B>(3),

<B><A HREF="../man3/sigemptyset.3.html">sigemptyset</A></B>(3),

<B><A HREF="../man3/sigfillset.3.html">sigfillset</A></B>(3),

<B><A HREF="../man3/sigismember.3.html">sigismember</A></B>(3),

<B><A HREF="../man7/epoll.7.html">epoll</A></B>(7)



<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE">Arguments</A><DD>
<DT><A HREF="#lbAF">Combining signal and data events</A><DD>
<DT><A HREF="#lbAG">Practical</A><DD>
<DT><A HREF="#lbAH">Select law</A><DD>
<DT><A HREF="#lbAI">Usleep emulation</A><DD>
</DL>
<DT><A HREF="#lbAJ">RETURN VALUE</A><DD>
<DT><A HREF="#lbAK">NOTES</A><DD>
<DT><A HREF="#lbAL">EXAMPLE</A><DD>
<DT><A HREF="#lbAM">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 03:50:52 GMT, April 20, 2020
</BODY>
</HTML>
