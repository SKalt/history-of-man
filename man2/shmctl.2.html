<!--
Copyright (c) 1993 Luigi P. Bai (lpb@softint.com) July 28, 1993
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of SHMCTL</TITLE>
</HEAD><BODY>
<H1>SHMCTL</H1>
Section: 2.6.11 Linux (2)<BR>Updated: 2005-05-30<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

shmctl - shared memory control
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>


<B>#include &lt;<A HREF="file:///usr/include/sys/ipc.h">sys/ipc.h</A>&gt;</B>

<P>
<B>#include &lt;<A HREF="file:///usr/include/sys/shm.h">sys/shm.h</A>&gt;</B>

<P>
<B>int shmctl(int </B><I>shmid</I><B>, int </B><I>cmd</I><B>, struct shmid_ds *</B><I>buf</I><B>);</B>


<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<B>shmctl</B>()

allows the caller to obtain information about a shared memory segment,
set the owner, group, and permissions of a segment,
or destroy a segment.
<P>

The
<I>buf</I>

argument is a pointer to a <I>shmid_ds</I> structure,
defined in &lt;<A HREF="file:///usr/include/sys/shm.h">sys/shm.h</A>&gt; as follows:
<P>


<PRE>
struct shmid_ds {
    struct ipc_perm shm_perm;    /* Ownership and permissions */
    size_t          shm_segsz;   /* Size of segment (bytes) */
    time_t          shm_atime;   /* Last attach time */
    time_t          shm_dtime;   /* Last detach time */
    time_t          shm_ctime;   /* Last change time */
    pid_t           shm_cpid;    /* PID of creator */
    pid_t           shm_lpid;    /* PID of last shmat()/shmdt() */
    shmatt_t        shm_nattch;  /* No. of current attaches */
    ...
};
</PRE>


<P>

The
<I>ipc_perm</I>

structure is defined in &lt;<A HREF="file:///usr/include/sys/ipc.h">sys/ipc.h</A>&gt; as follows
(the highlighted fields are settable using
<B>IPC_SET</B>):

<P>


<PRE>
struct ipc_perm {
    key_t key;            /* Key supplied to shmget() */
    uid_t <B>uid</B>;            /* Effective UID of owner */
    gid_t <B>gid</B>;            /* Effective GID of owner */
    uid_t cuid;           /* Effective UID of creator */
    gid_t cgid;           /* Effective GID of creator */
    unsigned short <B>mode</B>;  /* <B>Permissions</B> + SHM_DEST and
                             SHM_LOCKED flags */
    unsigned short seq;   /* Sequence number */
};
</PRE>


<P>

Valid values for
<I>cmd</I>

are:
<BR>

<DL COMPACT>
<DT><B>IPC_STAT</B>

<DD>
Copy information from the kernel data structure associated with
<I>shmid</I>

into the
<I>shmid_ds</I>

structure pointed to by <I>buf</I>.
The caller must have read permission on the
shared memory segment.
<DT><B>IPC_SET</B>

<DD>
Write the values of some members of the
<I>shmid_ds</I>

structure pointed to by
<I>arg.buf</I>

to the kernel data structure associated with this shared memory segment,
updating also its
<I>shm_ctime</I>

member.
The following fields can be changed:
<I>shm_perm.uid</I>, <I>shm_perm.gid</I>,
and (the least significant 9 bits of) <I>shm_perm.mode</I>.
The effective UID of the calling process must match the owner
(<I>shm_perm.uid</I>)

or creator
(<I>shm_perm.cuid</I>)

of the shared memory segment, or the caller must be privileged.
<DT><B>IPC_RMID</B>

<DD>
Mark the segment to be destroyed.
The segment will only actually be destroyed
after the last process detaches it (i.e., when the
<I>shm_nattch</I>

member of the associated structure
<I>shmid_ds</I>

is zero).
The caller must be the owner or creator, or be privileged.
If a segment has been marked for destruction, then the (non-standard)
<B>SHM_DEST</B>

flag of the
<I>shm_perm.mode</I>

field in the associated data structure retrieved by
<B>IPC_STAT</B>

will be set.
</DL>
<P>

The caller <I>must</I> ensure that a segment is eventually destroyed;
otherwise its pages that were faulted in will remain in memory or swap.
<A NAME="lbAE">&nbsp;</A>
<H3>Linux additions</H3>

The
<B>IPC_INFO</B>,

<B>SHM_STAT</B>

and
<B>SHM_INFO</B>

control calls are used by the
<B><A HREF="../man8/ipcs.8.html">ipcs</A></B>(8)

program to provide information on allocated resources.
<P>

The caller can prevent or allow swapping of a shared
memory segment with the following <I>cmd</I> values:
<BR>

<DL COMPACT>
<DT><B>SHM_LOCK</B>

<DD>
Prevent swapping of the shared memory segment. The caller must fault in
any pages that are required to be present after locking is enabled.
If a segment has been locked, then the (non-standard)
<B>SHM_LOCKED</B>

flag of the
<I>shm_perm.mode</I>

field in the associated data structure retrieved by
<B>IPC_STAT</B>

will be set.
<DT><B>SHM_UNLOCK</B>

<DD>
Unlock the segment, allowing it to be swapped out.
</DL>
<P>

In kernels before 2.6.10, only a privileged process
could employ
<B>SHM_LOCK</B>

and
<B>SHM_UNLOCK</B>.

Since kernel 2.6.10, an unprivileged process can employ these operations 
if its effective UID matches the owner or creator UID of the segment, and
(for
<B>SHM_LOCK</B>)

the amount of memory to be locked falls within the
<B>RLIMIT_MEMLOCK</B>

resource limit (see
<B><A HREF="../man2/setrlimit.2.html">setrlimit</A></B>(2)).





<A NAME="lbAF">&nbsp;</A>
<H2>RETURN VALUE</H2>

On success, zero is returned.
On error, -1 is returned, and
<I>errno</I>

is set appropriately.
<A NAME="lbAG">&nbsp;</A>
<H2>ERRORS</H2>

<DL COMPACT>
<DT><B>EACCES</B>

<DD>
<B>IPC_STAT</B> or <B>SHM_STAT</B> is requested and
<I>shm_perm.mode</I> does not allow read access for
<I>shmid</I>,

and the calling process does not have the
<B>CAP_IPC_OWNER</B>

capability.
<DT><B>EFAULT</B>

<DD>
The argument
<I>cmd</I>

has value
<B>IPC_SET</B>

or
<B>IPC_STAT</B>

but the address pointed to by
<I>buf</I>

isn't accessible.
<DT><B>EIDRM</B>

<DD>
<I>shmid</I> points to a removed identifier.
<DT><B>EINVAL</B>

<DD>
<I>shmid</I> is not a valid identifier, or <I>cmd</I>
is not a valid command.
<DT><B>ENOMEM</B>

<DD>
(In kernels since 2.6.9),
<B>SHM_LOCK</B>

was specified and the size of the to-be-locked segment would mean 
that the total bytes in locked shared memory segments would exceed
the limit for the real user ID of the calling process.
This limit is defined by the
<B>RLIMIT_MEMLOCK</B>

soft resource limit (see
<B><A HREF="../man2/setrlimit.2.html">setrlimit</A></B>(2)).

<DT><B>EOVERFLOW</B>

<DD>
<B>IPC_STAT</B> is attempted, and the gid or uid value
is too large to be stored in the structure pointed to by
<I>buf</I>.

<DT><B>EPERM</B>

<DD>
<B>IPC_SET</B> or <B>IPC_RMID</B> is attempted, and the
effective user ID of the calling process is not that of the creator
(found in
<I>shm_perm.cuid</I>),

or the owner
(found in
<I>shm_perm.uid</I>),

and the process was not privileged (Linux: did not have the
<B>CAP_SYS_ADMIN</B>

capability).
<P>
Or (in kernels before 2.6.9),
<B>SHM_LOCK</B>

or
<B>SHM_UNLOCK</B>

was specified, but the process was not privileged
(Linux: did not have the
<B>CAP_IPC_LOCK</B>

capability).
(Since Linux 2.6.9, this error can also occur if the
<B>RLIMIT_MEMLOCK</B>

is 0 and the caller is not privileged.)
</DL>
<A NAME="lbAH">&nbsp;</A>
<H2>NOTES</H2>

Linux permits a process to attach 
(<B>shmat</B>())

a shared memory segment that has already been marked for deletion
using
<I>shmctl(IPC_RMID)</I>.

This feature is not available on other Unix implementations;
portable applications should avoid relying on it.
<P>
Various fields in a <I>struct shmid_ds</I> were shorts under Linux 2.2
and have become longs under Linux 2.4. To take advantage of this,
a recompilation under glibc-2.1.91 or later should suffice.
(The kernel distinguishes old and new calls by an IPC_64 flag in
<I>cmd</I>.)

<A NAME="lbAI">&nbsp;</A>
<H2>CONFORMING TO</H2>

SVr4, SVID.  SVr4 documents additional error conditions EINVAL,
ENOENT, ENOSPC, ENOMEM, EEXIST.  Neither SVr4 nor SVID documents
an EIDRM error condition.
<A NAME="lbAJ">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="../man2/mlock.2.html">mlock</A></B>(2),

<B><A HREF="../man2/setrlimit.2.html">setrlimit</A></B>(2),

<B><A HREF="../man2/shmget.2.html">shmget</A></B>(2),

<B><A HREF="../man2/shmop.2.html">shmop</A></B>(2),

<B><A HREF="../man7/capabilities.7.html">capabilities</A></B>(7)

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE">Linux additions</A><DD>
</DL>
<DT><A HREF="#lbAF">RETURN VALUE</A><DD>
<DT><A HREF="#lbAG">ERRORS</A><DD>
<DT><A HREF="#lbAH">NOTES</A><DD>
<DT><A HREF="#lbAI">CONFORMING TO</A><DD>
<DT><A HREF="#lbAJ">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 02:13:10 GMT, April 20, 2020
</BODY>
</HTML>
