<!--
Copyright (C) 2015 Michael Kerrisk &lt;mtk.manpages@gmail.com&gt;
%%%LICENSE_START(VERBATIM)
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
.\"
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.
.\"
Since the Linux kernel and libraries are constantly changing, this
manual page may be incorrect or out-of-date.  The author(s) assume no
responsibility for errors or omissions, or for damages resulting from
the use of the information contained herein.  The author(s) may not
have taken the same level of care in the production of this manual,
which is licensed free of charge, as they might when working
professionally.
.\"
Formatted or processed versions of this manual, if unaccompanied by
the source, must acknowledge the copyright and authors of this work.
%%%LICENSE_END
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of DLADDR</TITLE>
</HEAD><BODY>
<H1>DLADDR</H1>
Section: Linux Programmer's Manual (3)<BR>Updated: 2017-09-15<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

dladdr, dladdr1 - translate address to symbolic information
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<PRE>
<B>#define _GNU_SOURCE</B>
<B>#include &lt;<A HREF="file:///usr/include/dlfcn.h">dlfcn.h</A>&gt;</B>

<B>int dladdr(void *</B><I>addr</I><B>, Dl_info *</B><I>info</I><B>);</B>

<B>int dladdr1(void *</B><I>addr</I><B>, Dl_info *</B><I>info</I><B>, void **</B><I></I><B>extra_info</B><I>, int </I><B>flags</B><I>);</I>

Link with <I>-ldl</I>.
</PRE>

<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

The function
<B>dladdr</B>()

determines whether the address specified in
<I>addr</I>

is located in one of the shared objects loaded by the calling application.
If it is, then
<B>dladdr</B>()

returns information about the shared object and symbol that overlaps
<I>addr</I>.

This information is returned in a
<I>Dl_info</I>

structure:
<P>



typedef struct {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*dli_fname;&nbsp;&nbsp;/*&nbsp;Pathname&nbsp;of&nbsp;shared&nbsp;object&nbsp;that
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;contains&nbsp;address&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*dli_fbase;&nbsp;&nbsp;/*&nbsp;Base&nbsp;address&nbsp;at&nbsp;which&nbsp;shared
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;is&nbsp;loaded&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;const&nbsp;char&nbsp;*dli_sname;&nbsp;&nbsp;/*&nbsp;Name&nbsp;of&nbsp;symbol&nbsp;whose&nbsp;definition
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;overlaps&nbsp;<I>addr</I>&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*dli_saddr;&nbsp;&nbsp;/*&nbsp;Exact&nbsp;address&nbsp;of&nbsp;symbol&nbsp;named
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;in&nbsp;<I>dli_sname</I>&nbsp;*/
} Dl_info;


<P>

If no symbol matching
<I>addr</I>

could be found, then
<I>dli_sname</I>

and
<I>dli_saddr</I>

are set to NULL.
<P>

The function
<B>dladdr1</B>()

is like
<B>dladdr</B>(),

but returns additional information via the argument
<I>extra_info</I>.

The information returned depends on the value specified in
<I>flags</I>,

which can have one of the following values:
<DL COMPACT>
<DT><B>RTLD_DL_LINKMAP</B>

<DD>
Obtain a pointer to the link map for the matched file.
The
<I>extra_info</I>

argument points to a pointer to a
<I>link_map</I>

structure (i.e.,
<I>struct link_map&nbsp;**</I>),

defined in
<I>&lt;<A HREF="file:///usr/include/link.h">link.h</A>&gt;</I>

as:
<DT><DD>


struct link_map {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ElfW(Addr)&nbsp;l_addr;&nbsp;&nbsp;/*&nbsp;Difference&nbsp;between&nbsp;the
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;address&nbsp;in&nbsp;the&nbsp;ELF&nbsp;file&nbsp;and
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;address&nbsp;in&nbsp;memory&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;*l_name;&nbsp;&nbsp;/*&nbsp;Absolute&nbsp;pathname&nbsp;where
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;object&nbsp;was&nbsp;found&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;ElfW(Dyn)&nbsp;*l_ld;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Dynamic&nbsp;section&nbsp;of&nbsp;the
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shared&nbsp;object&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;link_map&nbsp;*l_next,&nbsp;*l_prev;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Chain&nbsp;of&nbsp;loaded&nbsp;objects&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Plus&nbsp;additional&nbsp;fields&nbsp;private&nbsp;to&nbsp;the
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;implementation&nbsp;*/
};


<DT><B>RTLD_DL_SYMENT</B>

<DD>
Obtain a pointer to the ELF symbol table entry of the matching symbol.
The
<I>extra_info</I>

argument is a pointer to a symbol pointer:
<I>const ElfW(Sym) **</I>.

The
<I>ElfW</I>()

macro definition turns its argument into the name of an ELF data
type suitable for the hardware architecture.
For example, on a 64-bit platform,
<I>ElfW(Sym)</I>

yields the data type name
<I>Elf64_Sym</I>,

which is defined in
<I>&lt;<A HREF="file:///usr/include/elf.h">elf.h</A>&gt;</I>

as:
<DT><DD>


typedef struct  {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Elf64_Word&nbsp;&nbsp;&nbsp;&nbsp;st_name;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Symbol&nbsp;name&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;st_info;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Symbol&nbsp;type&nbsp;and&nbsp;binding&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;unsigned&nbsp;char&nbsp;st_other;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Symbol&nbsp;visibility&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Elf64_Section&nbsp;st_shndx;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Section&nbsp;index&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Elf64_Addr&nbsp;&nbsp;&nbsp;&nbsp;st_value;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Symbol&nbsp;value&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;Elf64_Xword&nbsp;&nbsp;&nbsp;st_size;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Symbol&nbsp;size&nbsp;*/
} Elf64_Sym;


<DT><DD>
The
<I>st_name</I>

field is an index into the string table.
<DT><DD>
The
<I>st_info</I>

field encodes the symbol's type and binding.
The type can be extracted using the macro
<B>ELF64_ST_TYPE(st_info)</B>

(or
<B>ELF32_ST_TYPE()</B>

on 32-bit platforms), which yields one of the following values:

<TABLE>
<TR VALIGN=top><TD><B>Value</B></TD><TD><B>Description</B><BR></TD></TR>
<TR VALIGN=top><TD><B>STT_NOTYPE</B></TD><TD>Symbol type is unspecified<BR></TD></TR>
<TR VALIGN=top><TD><B>STT_OBJECT</B></TD><TD>Symbol is a data object<BR></TD></TR>
<TR VALIGN=top><TD><B>STT_FUNC</B></TD><TD>Symbol is a code object<BR></TD></TR>
<TR VALIGN=top><TD><B>STT_SECTION</B></TD><TD>Symbol associated with a section<BR></TD></TR>
<TR VALIGN=top><TD><B>STT_FILE</B></TD><TD>Symbol's name is file name<BR></TD></TR>
<TR VALIGN=top><TD><B>STT_COMMON</B></TD><TD>Symbol is a common data object<BR></TD></TR>
<TR VALIGN=top><TD><B>STT_TLS</B></TD><TD>Symbol is thread-local data object<BR></TD></TR>
<TR VALIGN=top><TD><B>STT_GNU_IFUNC</B></TD><TD>Symbol is indirect code object<BR></TD></TR>
</TABLE>


<DT><DD>
The symbol binding can be extracted from the
<I>st_info</I>

field using the macro
<B>ELF64_ST_BIND(st_info)</B>

(or
<B>ELF32_ST_BIND()</B>

on 32-bit platforms), which yields one of the following values:

<TABLE>
<TR VALIGN=top><TD><B>Value</B></TD><TD><B>Description</B><BR></TD></TR>
<TR VALIGN=top><TD><B>STB_LOCAL</B></TD><TD>Local symbol<BR></TD></TR>
<TR VALIGN=top><TD><B>STB_GLOBAL</B></TD><TD>Global symbol<BR></TD></TR>
<TR VALIGN=top><TD><B>STB_WEAK</B></TD><TD>Weak symbol<BR></TD></TR>
<TR VALIGN=top><TD><B>STB_GNU_UNIQUE</B></TD><TD>Unique symbol<BR></TD></TR>
</TABLE>


<DT><DD>
The
<I>st_other</I>

field contains the symbol's visibility, which can be extracted using the macro
<B>ELF64_ST_VISIBILITY(st_info)</B>

(or
<B>ELF32_ST_VISIBILITY()</B>

on 32-bit platforms), which yields one of the following values:

<TABLE>
<TR VALIGN=top><TD><B>Value</B></TD><TD><B>Description</B><BR></TD></TR>
<TR VALIGN=top><TD><B>STV_DEFAULT</B></TD><TD>Default symbol visibility rules<BR></TD></TR>
<TR VALIGN=top><TD><B>STV_INTERNAL</B></TD><TD>Processor-specific hidden class<BR></TD></TR>
<TR VALIGN=top><TD><B>STV_HIDDEN</B></TD><TD>Symbol unavailable in other modules<BR></TD></TR>
<TR VALIGN=top><TD><B>STV_PROTECTED</B></TD><TD>Not preemptible, not exported<BR></TD></TR>
</TABLE>


</DL>
<A NAME="lbAE">&nbsp;</A>
<H2>RETURN VALUE</H2>

On success, these functions return a nonzero value.
If the address specified in
<I>addr</I>

could be matched to a shared object,
but not to a symbol in the shared object, then the
<I>info-&gt;dli_sname</I>

and
<I>info-&gt;dli_saddr</I>

fields are set to NULL.
<P>

If the address specified in
<I>addr</I>

could not be matched to a shared object, then these functions return 0.
In this case, an error message is
<I>not</I>



available via
<B><A HREF="../man3/dlerror.3.html">dlerror</A></B>(3).

<A NAME="lbAF">&nbsp;</A>
<H2>VERSIONS</H2>

<B>dladdr</B>()

is present in glibc 2.0 and later.
<B>dladdr1</B>()

first appeared in glibc 2.3.3.
<A NAME="lbAG">&nbsp;</A>
<H2>ATTRIBUTES</H2>

For an explanation of the terms used in this section, see
<B><A HREF="../man7/attributes.7.html">attributes</A></B>(7).

<TABLE BORDER>
<TR VALIGN=top><TD><B>Interface</B></TD><TD><B>Attribute</B></TD><TD><B>Value</B><BR></TD></TR>
<TR VALIGN=top><TD>
<B>dladdr</B>(),

<B>dladdr1</B>()

</TD><TD>Thread safety</TD><TD>MT-Safe<BR></TD></TR>
</TABLE>

<A NAME="lbAH">&nbsp;</A>
<H2>CONFORMING TO</H2>

These functions are nonstandard GNU extensions
that are also present on Solaris.
<A NAME="lbAI">&nbsp;</A>
<H2>BUGS</H2>

Sometimes, the function pointers you pass to
<B>dladdr</B>()

may surprise you.
On some architectures (notably i386 and x86-64),
<I>dli_fname</I>

and
<I>dli_fbase</I>

may end up pointing back at the object from which you called
<B>dladdr</B>(),

even if the function used as an argument should come from
a dynamically linked library.
<P>

The problem is that the function pointer will still be resolved
at compile time, but merely point to the
<I>plt</I>

(Procedure Linkage Table)
section of the original object (which dispatches the call after
asking the dynamic linker to resolve the symbol).
To work around this,
you can try to compile the code to be position-independent:
then, the compiler cannot prepare the pointer
at compile time any more and
<B><A HREF="../man1/gcc.1.html">gcc</A></B>(1)

will generate code that just loads the final symbol address from the
<I>got</I>

(Global Offset Table) at run time before passing it to
<B>dladdr</B>().

<A NAME="lbAJ">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="../man3/dl_iterate_phdr.3.html">dl_iterate_phdr</A></B>(3),

<B><A HREF="../man3/dlinfo.3.html">dlinfo</A></B>(3),

<B><A HREF="../man3/dlopen.3.html">dlopen</A></B>(3),

<B><A HREF="../man3/dlsym.3.html">dlsym</A></B>(3),

<B><A HREF="../man8/ld.so.8.html">ld.so</A></B>(8)

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">RETURN VALUE</A><DD>
<DT><A HREF="#lbAF">VERSIONS</A><DD>
<DT><A HREF="#lbAG">ATTRIBUTES</A><DD>
<DT><A HREF="#lbAH">CONFORMING TO</A><DD>
<DT><A HREF="#lbAI">BUGS</A><DD>
<DT><A HREF="#lbAJ">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 03:50:56 GMT, April 20, 2020
</BODY>
</HTML>
