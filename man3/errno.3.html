<!--
Copyright (c) 1996 Andries Brouwer (aeb@cwi.nl)
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of ERRNO</TITLE>
</HEAD><BODY>
<H1>ERRNO</H1>
Section: Library functions (3)<BR>Updated: 2004-12-17<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

errno - number of last error
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<B>#include &lt;<A HREF="file:///usr/include/errno.h">errno.h</A>&gt;</B>



<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

The 
<I>&lt;<A HREF="file:///usr/include/errno.h">errno.h</A>&gt;</I>

header file defines the integer variable
<B>errno</B>,

which is set by system calls and some library functions in the event
of an error to indicate what went wrong.
Its value is significant only when the call
returned an error (usually -1), and a function that does succeed
is allowed to change
<B>errno</B>.

<P>
Sometimes, when -1 is also a valid successful return value
one has to zero
<B>errno</B>

before the call in order to detect possible errors.
<P>
<B>errno</B> is defined by the ISO C standard to be a modifiable lvalue
of type <B>int</B>, and must not be explicitly declared; <B>errno</B>
may be a macro.  <B>errno</B> is thread-local; setting it in one thread
does not affect its value in any other thread.
<P>
Valid error numbers are all non-zero; <B>errno</B> is never set to zero
by any library function.  All the error names specified by POSIX.1
must have distinct values, with the exception of
<B>EAGAIN</B>

and 
<B>EWOULDBLOCK</B>,

which may be the same.
<P>

POSIX.1 (2001 edition) lists the following symbolic error names.  Of
these, <B>EDOM</B> and <B>ERANGE</B> are in the ISO C standard.  ISO C
Amendment 1 defines the additional error number <B>EILSEQ</B> for
coding errors in multibyte or wide characters.
<P>
<DL COMPACT>
<DT><B>E2BIG</B>

<DD>
Arg list too long
<DT><B>EACCES</B>

<DD>
Permission denied
<DT><B>EADDRINUSE</B>

<DD>
Address in use
<DT><B>EADDRNOTAVAIL</B>

<DD>
Address not available
<DT><B>EAFNOSUPPORT</B>

<DD>
Address family not supported
<DT><B>EAGAIN</B>

<DD>
Resource temporarily unavailable
<DT><B>EALREADY</B>

<DD>
Connection already in progress
<DT><B>EBADF</B>

<DD>
Bad file descriptor
<DT><B>EBADMSG</B>

<DD>
Bad message
<DT><B>EBUSY</B>

<DD>
Resource busy
<DT><B>ECANCELED</B>

<DD>
Operation canceled
<DT><B>ECHILD</B>

<DD>
No child processes
<DT><B>ECONNABORTED</B>

<DD>
Connection aborted
<DT><B>ECONNREFUSED</B>

<DD>
Connection refused
<DT><B>ECONNRESET</B>

<DD>
Connection reset
<DT><B>EDEADLK</B>

<DD>
Resource deadlock avoided
<DT><B>EDESTADDRREQ</B>

<DD>
Destination address required
<DT><B>EDOM</B>

<DD>
Domain error
<DT><B>EDQUOT</B>

<DD>
Reserved
<DT><B>EEXIST</B>

<DD>
File exists
<DT><B>EFAULT</B>

<DD>
Bad address
<DT><B>EFBIG</B>

<DD>
File too large
<DT><B>EHOSTUNREACH</B>

<DD>
Host is unreachable
<DT><B>EIDRM</B>

<DD>
Identifier removed
<DT><B>EILSEQ</B>

<DD>
Illegal byte sequence
<DT><B>EINPROGRESS</B>

<DD>
Operation in progress
<DT><B>EINTR</B>

<DD>
Interrupted function call
<DT><B>EINVAL</B>

<DD>
Invalid argument
<DT><B>EIO</B>

<DD>
Input/output error
<DT><B>EISCONN</B>

<DD>
Socket is connected
<DT><B>EISDIR</B>

<DD>
Is a directory
<DT><B>ELOOP</B>

<DD>
Too many levels of symbolic links
<DT><B>EMFILE</B>

<DD>
Too many open files
<DT><B>EMLINK</B>

<DD>
Too many links
<DT><B>EMSGSIZE</B>

<DD>
Inappropriate message buffer length
<DT><B>EMULTIHOP</B>

<DD>
Reserved
<DT><B>ENAMETOOLONG</B>

<DD>
Filename too long
<DT><B>ENETDOWN</B>

<DD>
Network is down
<DT><B>ENETRESET</B>

<DD>
Connection aborted by network
<DT><B>ENETUNREACH</B>

<DD>
Network unreachable
<DT><B>ENFILE</B>

<DD>
Too many open files in system
<DT><B>ENOBUFS</B>

<DD>
No buffer space available

<DT><B>ENODATA</B>

<DD>
No message is available on the STREAM head read queue
<DT><B>ENODEV</B>

<DD>
No such device
<DT><B>ENOENT</B>

<DD>
No such file or directory
<DT><B>ENOEXEC</B>

<DD>
Exec format error
<DT><B>ENOLCK</B>

<DD>
No locks available
<DT><B>ENOLINK</B>

<DD>
Reserved
<DT><B>ENOMEM</B>

<DD>
Not enough space
<DT><B>ENOMSG</B>

<DD>
No message of the desired type
<DT><B>ENOPROTOOPT</B>

<DD>
Protocol not available
<DT><B>ENOSPC</B>

<DD>
No space left on device

<DT><B>ENOSR</B>

<DD>
No STREAM resources

<DT><B>ENOSTR</B>

<DD>
Not a STREAM
<DT><B>ENOSYS</B>

<DD>
Function not implemented
<DT><B>ENOTCONN</B>

<DD>
The socket is not connected
<DT><B>ENOTDIR</B>

<DD>
Not a directory
<DT><B>ENOTEMPTY</B>

<DD>
Directory not empty
<DT><B>ENOTSOCK</B>

<DD>
Not a socket
<DT><B>ENOTSUP</B>

<DD>
Not supported
<DT><B>ENOTTY</B>

<DD>
Inappropriate I/O control operation
<DT><B>ENXIO</B>

<DD>
No such device or address
<DT><B>EOPNOTSUPP</B>

<DD>
Operation not supported on socket
<DT><B>EOVERFLOW</B>

<DD>
Value too large to be stored in data type
<DT><B>EPERM</B>

<DD>
Operation not permitted
<DT><B>EPIPE</B>

<DD>
Broken pipe
<DT><B>EPROTO</B>

<DD>
Protocol error
<DT><B>EPROTONOSUPPORT</B>

<DD>
Protocol not supported
<DT><B>EPROTOTYPE</B>

<DD>
Protocol wrong type for socket
<DT><B>ERANGE</B>

<DD>
Result too large
<DT><B>EROFS</B>

<DD>
Read-only file system
<DT><B>ESPIPE</B>

<DD>
Invalid seek
<DT><B>ESRCH</B>

<DD>
No such process
<DT><B>ESTALE</B>

<DD>
Stale file handle


<DT><B>ETIME</B>

<DD>
STREAM 
<B>ioctl</B>()

timeout
<DT><B>ETIMEDOUT</B>

<DD>
Operation timed out
<DT><B>ETXTBSY</B>

<DD>
Text file busy
<DT><B>EWOULDBLOCK</B>

<DD>
Operation would block (may be same value as
<B>EAGAIN</B>)

<DT><B>EXDEV</B>

<DD>
Improper link
</DL>
<A NAME="lbAE">&nbsp;</A>
<H2>NOTES</H2>

A common mistake is to do
<DL COMPACT><DT><DD>
<PRE>

if (somecall() == -1) {
    printf(&quot;somecall() failed\n&quot;);
    if (errno == ...) { ... }
}

</PRE>

</DL>

where
<I>errno</I>

no longer needs to have the value it had upon return from
<I>somecall</I>()

(i.e., it may have been changed by the
<I>printf</I>()).

If the value of
<I>errno</I>

should be preserved across a library call, it must be saved:
<DL COMPACT><DT><DD>
<PRE>

if (somecall() == -1) {
    int errsv = errno;
    printf(&quot;somecall() failed\n&quot;);
    if (errsv == ...) { ... }
}
</PRE>

</DL>

<P>

It was common in traditional C to declare
<I>errno</I>

manually
(i.e., 
<I>extern int errno</I>)

instead of including
<I>&lt;<A HREF="file:///usr/include/errno.h">errno.h</A>&gt;</I>.

<B>Do not do this</B>.

It will not work with modern versions of the C library.
However, on (very) old Unix systems, there may be no
<I>&lt;<A HREF="file:///usr/include/errno.h">errno.h</A>&gt;</I>

and the declaration is needed.
<A NAME="lbAF">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="../man3/perror.3.html">perror</A></B>(3),

<B><A HREF="../man3/strerror.3.html">strerror</A></B>(3)

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">NOTES</A><DD>
<DT><A HREF="#lbAF">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 02:16:37 GMT, April 20, 2020
</BODY>
</HTML>
