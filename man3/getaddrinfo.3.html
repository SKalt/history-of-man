<!--
Copyright 2000 Sam Varshavchik &lt;mrsam@courier-mta.com&gt;
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of GETADDRINFO</TITLE>
</HEAD><BODY>
<H1>GETADDRINFO</H1>
Section: Linux Programmer's Manual (3)<BR>Updated: 2007-11-15<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

getaddrinfo, freeaddrinfo, gai_strerror - network address and service translation
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<PRE>
<B>#include &lt;<A HREF="file:///usr/include/sys/types.h">sys/types.h</A>&gt;</B>
<B>#include &lt;<A HREF="file:///usr/include/sys/socket.h">sys/socket.h</A>&gt;</B>
<B>#include &lt;<A HREF="file:///usr/include/netdb.h">netdb.h</A>&gt;</B>

<B>int getaddrinfo(const char *</B><I>node</I><B>, const char *</B><I>service</I><B>,</B>
<B>                const struct addrinfo *</B><I>hints</I><B>,</B>
<B>                struct addrinfo **</B><I>res</I><B>);</B>

<B>void freeaddrinfo(struct addrinfo *</B><I>res</I><B>);</B>

<B>const char *gai_strerror(int </B><I>errcode</I><B>);</B>
</PRE>

<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

The
<B>getaddrinfo</B>()

function combines the functionality provided by the


<B><A HREF="../man3/getservbyname.3.html">getservbyname</A></B>(3)

and
<B><A HREF="../man3/getservbyport.3.html">getservbyport</A></B>(3)

functions into a single interface.
The thread-safe
<B>getaddrinfo</B>()

function creates one or more socket address structures
that can be used by the
<B><A HREF="../man2/bind.2.html">bind</A></B>(2)

and
<B><A HREF="../man2/connect.2.html">connect</A></B>(2)

system calls to create a client or a server socket.
<P>

The
<B>getaddrinfo</B>()

function is not limited to creating IPv4 socket address structures;
IPv6 socket address structures can be created if IPv6 support is available.
These socket address structures can be used directly by
<B><A HREF="../man2/bind.2.html">bind</A></B>(2)

or
<B><A HREF="../man2/connect.2.html">connect</A></B>(2),

to prepare a client or a server socket.
<P>

The
<I>addrinfo</I>

structure used by this function contains the following members:
<P>
<PRE>
struct addrinfo {
    int              ai_flags;
    int              ai_family;
    int              ai_socktype;
    int              ai_protocol;
    size_t           ai_addrlen;
    struct sockaddr *ai_addr;
    char            *ai_canonname;
    struct addrinfo *ai_next;
};
</PRE>

<P>

<B>getaddrinfo</B>()

sets
<I>res</I>

to point to a dynamically allocated linked list of
<I>addrinfo</I>

structures, linked by the
<I>ai_next</I>

member.
There are several reasons why
the linked list may have more than one
<I>addrinfo</I>

structure, including: if the network host is
multi-homed; or if the same service
is available from multiple socket protocols (one
<B>SOCK_STREAM</B>

address and another
<B>SOCK_DGRAM</B>

address, for example).
<P>

The members
<I>ai_family</I>,

<I>ai_socktype</I>,

and
<I>ai_protocol</I>

have the same meaning as the corresponding parameters in the
<B><A HREF="../man2/socket.2.html">socket</A></B>(2)

system call.
The
<B>getaddrinfo</B>()

function returns socket addresses in either IPv4 or IPv6
address family,
(<I>ai_family</I>

will be set to either
<B>AF_INET</B>

or
<B>AF_INET6</B>).

<P>

The
<I>hints</I>

parameter specifies
the preferred socket type, or protocol.
A NULL
<I>hints</I>

specifies that any network address or protocol is acceptable.
If this parameter is not NULL it points to an
<I>addrinfo</I>

structure
whose
<I>ai_family</I>,

<I>ai_socktype</I>,

and
<I>ai_protocol</I>

members specify the preferred socket type.
<B>AF_UNSPEC</B>

in
<I>ai_family</I>

specifies any protocol family (either IPv4 or IPv6, for example).
0 in
<I>ai_socktype</I>

or
<I>ai_protocol</I>

specifies that any socket type or protocol is acceptable as well.
The
<I>ai_flags</I>

member
specifies additional options, defined below.
Multiple flags are specified by logically OR-ing them together.
All the other members in the
<I>hints</I>

parameter must contain either 0, or a null pointer.
<P>

The
<I>node</I>

or
<I>service</I>

parameter, but not both, may be NULL.
<I>node</I>

specifies either a numerical network address
(dotted-decimal format for IPv4, hexadecimal format for IPv6)
or a network hostname, whose network addresses are looked up and resolved.
If
<I>hints.ai_flags</I>

contains the
<B>AI_NUMERICHOST</B>

flag then the
<I>node</I>

parameter must be a numerical network address.
The
<B>AI_NUMERICHOST</B>

flag suppresses any potentially lengthy network host address lookups.
<P>

The
<B>getaddrinfo</B>()

function creates a linked list of
<I>addrinfo</I>

structures, one for each network address subject to any restrictions
imposed by the
<I>hints</I>

parameter.
The
<I>ai_canonname</I>

field of the first of these
<I>addrinfo</I>

structures is set to point to the official name of the host, if
<I>hints.ai_flags</I>

includes the
<B>AI_CANONNAME</B>

flag.




<I>ai_family</I>,

<I>ai_socktype</I>,

and
<I>ai_protocol</I>

specify the socket creation parameters.
A pointer to the socket address is placed in the
<I>ai_addr</I>

member, and the length of the socket address, in bytes,
is placed in the
<I>ai_addrlen</I>

member.
<P>

If
<I>node</I>

is NULL,
the
network address in each socket structure is initialized according to the
<B>AI_PASSIVE</B>

flag, which is set in
<I>hints.ai_flags</I>.

The network address in each socket structure will be left unspecified
if
<B>AI_PASSIVE</B>

flag is set.
This is used by server applications, which intend to accept
client connections on any network address.
The network address will be set to the loopback interface address
if the
<B>AI_PASSIVE</B>

flag is not set.
This is used by client applications, which intend to connect
to a server running on the same network host.
<P>

If
<I>hints.ai_flags</I>

includes the
<B>AI_ADDRCONFIG</B>

flag, then IPv4 addresses are returned in the list pointed to by
<I>result</I>

only if the local system has at least one
IPv4 address configured, and IPv6 addresses are only returned
if the local system has at least one IPv6 address configured.
<P>

If
<I>hint.ai_flags</I>

specifies the
<B>AI_V4MAPPED</B>

flag, and
<I>hints.ai_family</I>

was specified as
<B>AF_INET6</B>,

and no matching IPv6 addresses could be found,
then return IPv4-mapped IPv6 addresses in the list pointed to by
<I>result</I>.

If both
<B>AI_V4MAPPED</B>

and
<B>AI_ALL</B>

are specified in
<I>hints.ai_family</I>,

then return both IPv6 and IPv4-mapped IPv6 addresses
in the list pointed to by
<I>result</I>.

<B>AI_ALL</B>

is ignored if
<B>AI_V4MAPPED</B>

is not also specified.
<P>

<I>service</I>

sets the port number in the network address of each socket structure.
If
<I>service</I>

is NULL the port number will be left uninitialized.
If
<B>AI_NUMERICSERV</B>

is specified in
<I>hints.ai_flags</I>

and
<I>service</I>

is not NULL, then
<I>service</I>

must point to a string containing a numeric port number.
This flag is used to inhibit the invocation of a name resolution service
in cases where it is known not to be required.
<P>

The
<B>freeaddrinfo</B>()

function frees the memory that was allocated
for the dynamically allocated linked list
<I>res</I>.

<A NAME="lbAE">&nbsp;</A>
<H3>Extensions to getaddrinfo() for Internationalized Domain Names</H3>

<P>

Starting with glibc 2.3.4,
<B>getaddrinfo</B>()

has been extended to selectively allow the incoming and outgoing
host names to be transparently converted to and from the
Internationalized Domain Name (IDN) format (see RFC 3490,
<I>Internationalizing Domain Names in Applications (IDNA)</I>).

Four new flags are defined:
<DL COMPACT>
<DT><B>AI_IDN</B>

<DD>
If this flag is specified, then the node name given in
<I>node</I>

is converted to IDN format if necessary.
The source encoding is that of the current locale.
<P>
If the input name contains non-ASCII characters, then the IDN encoding
is used.
Those parts of the node name (delimited by dots) that contain
non-ASCII characters are encoded using ASCII Compatible Encoding (ACE)
before being passed to the name resolution functions.






<DT><B>AI_CANONIDN</B>

<DD>
After a successful name lookup, and if the
<B>AI_CANONNAME</B>

flag was specified,
<B>getaddrinfo</B>()

will return the canonical name of the
node corresponding to the
<I>addrinfo</I>

structure value passed back.
The return value is an exact copy of the value returned by the name
resolution function.
<P>
If the name is encoded using ACE, then it will contain the
<I>xn--</I>

prefix for one or more components of the name.
To convert these components into a readable form the
<B>AI_CANONIDN</B>

flag can be passed in addition to
<B>AI_CANONNAME</B>.

The resulting string is encoded using the current locale's encoding.




<DT><B>AI_IDN_ALLOW_UNASSIGNED</B>, <B>AI_IDN_USE_STD3_ASCII_RULES</B>

<DD>
Setting these flags will enable the
IDNA_ALLOW_UNASSIGNED (allow unassigned Unicode code points) and
IDNA_USE_STD3_ASCII_RULES (check output to make sure it is a STD3
conforming host name)
flags respectively to be used in the IDNA handling.
</DL>
<A NAME="lbAF">&nbsp;</A>
<H2>RETURN VALUE</H2>












<B>getaddrinfo</B>()

returns 0 if it succeeds, or one of the following non-zero error codes:
<DL COMPACT>
<DT><B>EAI_ADDRFAMILY</B>

<DD>
The specified network host does not have any network addresses in the
requested address family.
<DT><B>EAI_AGAIN</B>

<DD>
The name server returned a temporary failure indication.
Try again later.
<DT><B>EAI_BADFLAGS</B>

<DD>
<I>ai_flags</I>

contains invalid flags.
<DT><B>EAI_FAIL</B>

<DD>
The name server returned a permanent failure indication.
<DT><B>EAI_FAMILY</B>

<DD>
The requested address family is not supported at all.
<DT><B>EAI_MEMORY</B>

<DD>
Out of memory.
<DT><B>EAI_NODATA</B>

<DD>
The specified network host exists, but does not have any
network addresses defined.
<DT><B>EAI_NONAME</B>

<DD>
The
<I>node</I>

or
<I>service</I>

is not known; or both
<I>node</I>

and
<I>service</I>

are NULL; or
<B>AI_NUMERICSERV</B>

was specified in
<I>hints.ai_flags</I>

and
<I>service</I>

was not a numeric port-number string.
<DT><B>EAI_SERVICE</B>

<DD>
The requested service is not available for the requested socket type.
It may be available through another socket type.
<DT><B>EAI_SOCKTYPE</B>

<DD>
The requested socket type is not supported at all.
<DT><B>EAI_SYSTEM</B>

<DD>
Other system error, check
<I>errno</I>

for details.
</DL>
<P>

The
<B>gai_strerror</B>()

function translates these error codes to a human readable string,
suitable for error reporting.
<A NAME="lbAG">&nbsp;</A>
<H2>CONFORMING TO</H2>

POSIX.1-2001.
The
<B>getaddrinfo</B>()

function is documented in RFC&nbsp;2553.
<A NAME="lbAH">&nbsp;</A>
<H2>NOTES</H2>

<B>AI_ADDRCONFIG</B>,

<B>AI_ALL</B>,

and
<B>AI_V4MAPPED</B>

are available since glibc 2.3.3.
<B>AI_NUMERICSERV</B>

is available since glibc 2.3.4.
<A NAME="lbAI">&nbsp;</A>
<H2>EXAMPLE</H2>







The following programs demonstrate the use of
<B>getaddrinfo</B>(),

<B>gai_strerror</B>(),

<B>freeaddrinfo</B>(),

and
<B><A HREF="../man3/getnameinfo.3.html">getnameinfo</A></B>(3).

The programs are an echo server and client for UDP datagrams.
<P>
This is the server:

<PRE>

#include &lt;<A HREF="file:///usr/include/sys/types.h">sys/types.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/stdio.h">stdio.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/stdlib.h">stdlib.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/string.h">string.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/sys/socket.h">sys/socket.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/netdb.h">netdb.h</A>&gt;

#define BUF_SIZE 500

int
main(int argc, char *argv[])
{
    struct addrinfo hints;
    struct addrinfo *result, *rp;
    int sfd, s;
    struct sockaddr_storage peer_addr;
    socklen_t peer_addr_len;
    ssize_t nread;
    char buf[BUF_SIZE];

    if (argc != 2) {
        fprintf(stderr, &quot;Usage: %s port\n&quot;, argv[0]);
        exit(EXIT_FAILURE);
    }

    memset(&amp;hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
    hints.ai_flags = AI_PASSIVE;    /* For wildcard IP address */
    hints.ai_protocol = 0;          /* Any protocol */
    hints.ai_canonname = NULL;
    hints.ai_addr = NULL;
    hints.ai_next = NULL;

    s = getaddrinfo(NULL, argv[1], &amp;hints, &amp;result);
    if (s != 0) {
        fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(s));
        exit(EXIT_FAILURE);
    }

    /* getaddrinfo() returns a list of address structures.
       Try each address until we successfully <A HREF="../man2/bind.2.html">bind</A>(2).
       If <A HREF="../man2/socket.2.html">socket</A>(2) (or <A HREF="../man2/bind.2.html">bind</A>(2)) fails, we (close the socket
       and) try the next address. */

    for (rp = result; rp != NULL; rp = rp-&gt;ai_next) {
        sfd = socket(rp-&gt;ai_family, rp-&gt;ai_socktype,
                rp-&gt;ai_protocol);
        if (sfd == -1)
            continue;

        if (bind(sfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen) == 0)
            break;                  /* Success */

        close(sfd);
    }

    if (rp == NULL) {               /* No address succeeded */
        fprintf(stderr, &quot;Could not bind\n&quot;);
        exit(EXIT_FAILURE);
    }

    freeaddrinfo(result);           /* No longer needed */

    /* Read datagrams and echo them back to sender */

    for (;;) {
        peer_addr_len = sizeof(struct sockaddr_storage);
        nread = recvfrom(sfd, buf, BUF_SIZE, 0,
                (struct sockaddr *) &amp;peer_addr, &amp;peer_addr_len);
        if (nread == -1)
            continue;               /* Ignore failed request */

        char host[NI_MAXHOST], service[NI_MAXSERV];

        s = getnameinfo((struct sockaddr *) &amp;peer_addr,
                        peer_addr_len, host, NI_MAXHOST,
                        service, NI_MAXSERV, NI_NUMERICSERV);
       if (s == 0)
            printf(&quot;Received %ld bytes from %s:%s\n&quot;,
                    (long) nread, host, service);
        else
            fprintf(stderr, &quot;getnameinfo: %s\n&quot;, gai_strerror(s));

        if (sendto(sfd, buf, nread, 0,
                    (struct sockaddr *) &amp;peer_addr,
                    peer_addr_len) != nread)
            fprintf(stderr, &quot;Error sending response\n&quot;);
    }
}
</PRE>


<P>
This is the client:

<PRE>

#include &lt;<A HREF="file:///usr/include/sys/types.h">sys/types.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/sys/socket.h">sys/socket.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/netdb.h">netdb.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/stdio.h">stdio.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/stdlib.h">stdlib.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/string.h">string.h</A>&gt;

#define BUF_SIZE 500

int
main(int argc, char *argv[])
{
    struct addrinfo hints;
    struct addrinfo *result, *rp;
    int sfd, s, j;
    size_t len;
    ssize_t nread;
    char buf[BUF_SIZE];

    if (argc &lt; 3) {
        fprintf(stderr, &quot;Usage: %s host port msg...\n&quot;, argv[0]);
        exit(EXIT_FAILURE);
    }

    /* Obtain address(es) matching host/port */

    memset(&amp;hints, 0, sizeof(struct addrinfo));
    hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
    hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
    hints.ai_flags = 0;
    hints.ai_protocol = 0;          /* Any protocol */

    s = getaddrinfo(argv[1], argv[2], &amp;hints, &amp;result);
    if (s != 0) {
        fprintf(stderr, &quot;getaddrinfo: %s\n&quot;, gai_strerror(s));
        exit(EXIT_FAILURE);
    }

    /* getaddrinfo() returns a list of address structures.
       Try each address until we successfully <A HREF="../man2/connect.2.html">connect</A>(2).
       If <A HREF="../man2/socket.2.html">socket</A>(2) (or <A HREF="../man2/connect.2.html">connect</A>(2)) fails, we (close the socket
       and) try the next address. */

    for (rp = result; rp != NULL; rp = rp-&gt;ai_next) {
        sfd = socket(rp-&gt;ai_family, rp-&gt;ai_socktype,
                     rp-&gt;ai_protocol);
        if (sfd == -1)
            continue;

        if (connect(sfd, rp-&gt;ai_addr, rp-&gt;ai_addrlen) != -1)
            break;                  /* Success */

        close(sfd);
    }

    if (rp == NULL) {               /* No address succeeded */
        fprintf(stderr, &quot;Could not connect\n&quot;);
        exit(EXIT_FAILURE);
    }

    freeaddrinfo(result);           /* No longer needed */

    /* Send remaining command-line arguments as separate
       datagrams, and read responses from server */

    for (j = 3; j &lt; argc; j++) {
        len = strlen(argv[j]) + 1;
                /* +1 for terminating null byte */

        if (len + 1 &gt; BUF_SIZE) {
            fprintf(stderr,
                    &quot;Ignoring long message in argument %d\n&quot;, j);
            continue;
        }

        if (write(sfd, argv[j], len) != len) {
            fprintf(stderr, &quot;partial/failed write\n&quot;);
            exit(EXIT_FAILURE);
        }

        nread = read(sfd, buf, BUF_SIZE);
        if (nread == -1) {
            perror(&quot;read&quot;);
            exit(EXIT_FAILURE);
        }

        printf(&quot;Received %ld bytes: %s\n&quot;, (long) nread, buf);
    }

    exit(EXIT_SUCCESS);
}
</PRE>


<A NAME="lbAJ">&nbsp;</A>
<H2>SEE ALSO</H2>



<B><A HREF="../man3/getnameinfo.3.html">getnameinfo</A></B>(3)

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE">Extensions to getaddrinfo() for Internationalized Domain Names</A><DD>
</DL>
<DT><A HREF="#lbAF">RETURN VALUE</A><DD>
<DT><A HREF="#lbAG">CONFORMING TO</A><DD>
<DT><A HREF="#lbAH">NOTES</A><DD>
<DT><A HREF="#lbAI">EXAMPLE</A><DD>
<DT><A HREF="#lbAJ">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 02:49:04 GMT, April 20, 2020
</BODY>
</HTML>
