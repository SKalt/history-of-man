<!--
Copyright 1993 Ulrich Drepper (drepper@karlsruhe.gmd.de)
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of HSEARCH</TITLE>
</HEAD><BODY>
<H1>HSEARCH</H1>
Section: Linux Programmer's Manual (3)<BR>Updated: 2004-05-20<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

hcreate, hdestroy, hsearch - hash table management
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<B>#include &lt;<A HREF="file:///usr/include/search.h">search.h</A>&gt;</B>

<P>
<B>int hcreate(size_t </B><I>nel</I><B>);</B>

<P>
<B>ENTRY *hsearch(ENTRY </B><I>item</I><B>, ACTION </B><I>action</I><B>);</B>

<P>
<B>void hdestroy(void);</B>

<P>
<B>#define _GNU_SOURCE</B>

<BR>

<B>#include &lt;<A HREF="file:///usr/include/search.h">search.h</A>&gt;</B>

<P>
<B>int hcreate_r(size_t </B><I>nel</I><B>, struct hsearch_data *</B><I>tab</I><B>);</B>

<P>
<B>int hsearch_r(ENTRY </B><I>item</I><B>, ACTION </B><I>action</I><B>,</B>

<B>ENTRY **</B><I>ret</I><B>, struct hsearch_data *</B><I>tab</I><B>);</B>

<P>
<B>void hdestroy_r(struct hsearch_data *</B><I>tab</I><B>);</B>

<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

The three functions
<B>hcreate</B>,

<B>hsearch</B>,

and
<B>hdestroy</B>

allow the user to create a hash table (only one at a time)
which associates a key with any data.
<P>

First the table must be created with the function <B>hcreate()</B>.
The argument <I>nel</I> is an estimate of the maximum number of entries
in the table.
The function <B>hcreate()</B> may adjust this value upward to improve the
performance of the resulting hash table.
<P>

The corresponding function <B>hdestroy()</B> frees the memory occupied by
the hash table so that a new table can be constructed.
<P>

The argument <I>item</I> is of type <B>ENTRY</B>, which is a typedef defined in
<I>&lt;<A HREF="file:///usr/include/search.h">search.h</A>&gt;</I> and includes these elements:
<P>
<PRE>
        typedef struct entry { 
            char *<I>key</I>;
            void *<I>data</I>; 
        } ENTRY;
</PRE>

<P>
The field <I>key</I> points to the NUL-terminated string which is the
search key.
The field <I>data</I> points to the data associated with that key.
The function <B>hsearch()</B> searches the hash table for an
item with the same key as <I>item</I> (where &quot;the same&quot; is determined using
<B><A HREF="../man3/strcmp.3.html">strcmp</A></B>(3)),

and if successful returns a pointer to it.
The argument <I>action</I> determines what <B>hsearch()</B> does
after an unsuccessful search.  A value of <B>ENTER</B> instructs it to
insert a copy of <I>item</I>, while a value of <B>FIND</B> means to return
<B>NULL</B>.
<P>

The three functions
<B>hcreate_r</B>,

<B>hsearch_r</B>,

<B>hdestroy_r</B>

are reentrant versions that allow the use of more than one table.
The last argument used identifies the table. The struct it points to
must be zeroed before the first call to
<B>hcreate_r()</B>.

<A NAME="lbAE">&nbsp;</A>
<H2>RETURN VALUE</H2>

<B>hcreate()</B> and <B>hcreate_r()</B> return 0 when allocation of the memory
for the hash table fails, non-zero otherwise.
<P>

<B>hsearch()</B> returns <B>NULL</B> if <I>action</I> is <B>ENTER</B> and
the hash table is full, or <I>action</I> is <B>FIND</B> and <I>item</I>
cannot be found in the hash table.
<P>

<B>hsearch_r()</B> returns 0 if <I>action</I> is <B>ENTER</B> and
the hash table is full, and non-zero otherwise.
<A NAME="lbAF">&nbsp;</A>
<H2>ERRORS</H2>

POSIX documents
<DL COMPACT>
<DT><B>ENOMEM</B>

<DD>
Out of memory.
</DL>
<P>

The glibc implementation will return the following two errors.
<DL COMPACT>
<DT><B>ENOMEM</B>

<DD>
Table full with <I>action</I> set to <B>ENTER</B>.
<DT><B>ESRCH</B>

<DD>
The <I>action</I> parameter is <B>FIND</B> and no corresponding element
is found in the table.
</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>CONFORMS TO</H2>

The functions
<B>hcreate</B>,

<B>hsearch</B>,

and
<B>hdestroy</B>

are from SVID, and are described in POSIX 1003.1-2001.
The functions
<B>hcreate_r</B>,

<B>hsearch_r</B>,

<B>hdestroy_r</B>

are GNU extensions.
<A NAME="lbAH">&nbsp;</A>
<H2>BUGS</H2>

SVID and POSIX 1003.1-2001 specify that <I>action</I>
is significant only for unsuccessful searches, so that an ENTER
should not do anything for a successful search. The libc and glibc
implementations update the <I>data</I> for the given <I>key</I>
in this case.

<P>

Individual hash table entries can be added, but not deleted.
<A NAME="lbAI">&nbsp;</A>
<H2>EXAMPLE</H2>

<P>

The following program inserts 24 items in to a hash table, then prints
some of them.
<PRE>

    #include &lt;<A HREF="file:///usr/include/stdio.h">stdio.h</A>&gt;
    #include &lt;<A HREF="file:///usr/include/stdlib.h">stdlib.h</A>&gt;
    #include &lt;<A HREF="file:///usr/include/search.h">search.h</A>&gt;
    
    char *data[] = { &quot;alpha&quot;, &quot;bravo&quot;, &quot;charlie&quot;, &quot;delta&quot;,
         &quot;echo&quot;, &quot;foxtrot&quot;, &quot;golf&quot;, &quot;hotel&quot;, &quot;india&quot;, &quot;juliet&quot;,
         &quot;kilo&quot;, &quot;lima&quot;, &quot;mike&quot;, &quot;november&quot;, &quot;oscar&quot;, &quot;papa&quot;,
         &quot;quebec&quot;, &quot;romeo&quot;, &quot;sierra&quot;, &quot;tango&quot;, &quot;uniform&quot;,
         &quot;victor&quot;, &quot;whisky&quot;, &quot;x-ray&quot;, &quot;yankee&quot;, &quot;zulu&quot; 
    };

    int main() {
      ENTRY e, *ep;
      int i;
    
      /* starting with small table, and letting it grow does not work */
      hcreate(30);
      for (i = 0; i &lt; 24; i++) {
          e.key = data[i]; 
          /* data is just an integer, instead of a
             pointer to something */
          e.data = (void *)i;
          ep = hsearch(e, ENTER);
          /* there should be no failures */
          if (ep == NULL) {
            fprintf(stderr, &quot;entry failed\n&quot;);
            <A HREF="../man1/exit.1.html">exit</A>(1);
          }
      }
      for (i = 22; i &lt; 26; i++) {
          /* print two entries from the table, and
             show that two are not in the table */
          e.key = data[i];
          ep = hsearch(e, FIND);
          printf(&quot;%9.9s -&gt; %9.9s:%d\n&quot;, e.key,
                 ep ? ep-&gt;key : &quot;NULL&quot;,
                 ep ? (int)(ep-&gt;data) : 0);
      }
      return 0;
    }

</PRE>

<A NAME="lbAJ">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="../man3/bsearch.3.html">bsearch</A></B>(3),

<B><A HREF="../man3/lsearch.3.html">lsearch</A></B>(3),

<B><A HREF="../man3/malloc.3.html">malloc</A></B>(3),

<B><A HREF="../man3/tsearch.3.html">tsearch</A></B>(3)

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">RETURN VALUE</A><DD>
<DT><A HREF="#lbAF">ERRORS</A><DD>
<DT><A HREF="#lbAG">CONFORMS TO</A><DD>
<DT><A HREF="#lbAH">BUGS</A><DD>
<DT><A HREF="#lbAI">EXAMPLE</A><DD>
<DT><A HREF="#lbAJ">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 02:15:44 GMT, April 20, 2020
</BODY>
</HTML>
