<!--
Copyright (C) 2002, 2020 Michael Kerrisk &lt;mtk.manpages@gmail.com&gt;
%%%LICENSE_START(VERBATIM)
Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.
.\"
Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the
entire resulting derived work is distributed under the terms of a
permission notice identical to this one.
.\"
Since the Linux kernel and libraries are constantly changing, this
manual page may be incorrect or out-of-date.  The author(s) assume no
responsibility for errors or omissions, or for damages resulting from
the use of the information contained herein.  The author(s) may not
have taken the same level of care in the production of this manual,
which is licensed free of charge, as they might when working
professionally.
.\"
Formatted or processed versions of this manual, if unaccompanied by
the source, must acknowledge the copyright and authors of this work.
%%%LICENSE_END
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of SHM_OPEN</TITLE>
</HEAD><BODY>
<H1>SHM_OPEN</H1>
Section: Linux Programmer's Manual (3)<BR>Updated: 2020-04-11<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

shm_open, shm_unlink - create/open or unlink POSIX shared memory objects
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<B>#include &lt;<A HREF="file:///usr/include/sys/mman.h">sys/mman.h</A>&gt;</B>

<BR>

<B>#include &lt;<A HREF="file:///usr/include/sys/stat.h">sys/stat.h</A>&gt;</B>        /* For mode constants */

<BR>

<B>#include &lt;<A HREF="file:///usr/include/fcntl.h">fcntl.h</A>&gt;</B>           /* For O_* constants */

<P>

<B>int shm_open(const char *</B><I>name</I><B>, int </B><I>oflag</I><B>, mode_t </B><I>mode</I><B>);</B>

<P>

<B>int shm_unlink(const char *</B><I>name</I><B>);</B>

<P>

Link with <I>-lrt</I>.
<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<B>shm_open</B>()

creates and opens a new, or opens an existing, POSIX shared memory object.
A POSIX shared memory object is in effect a handle which can
be used by unrelated processes to
<B><A HREF="../man2/mmap.2.html">mmap</A></B>(2)

the same region of shared memory.
The
<B>shm_unlink</B>()

function performs the converse operation,
removing an object previously created by
<B>shm_open</B>().

<P>

The operation of
<B>shm_open</B>()

is analogous to that of
<B><A HREF="../man2/open.2.html">open</A></B>(2).

<I>name</I>

specifies the shared memory object to be created or opened.
For portable use,
a shared memory object should be identified by a name of the form
<I>/somename</I>;

that is, a null-terminated string of up to
<B>NAME_MAX</B>

(i.e., 255) characters consisting of an initial slash,



followed by one or more characters, none of which are slashes.




<P>

<I>oflag</I>

is a bit mask created by ORing together exactly one of
<B>O_RDONLY</B>

or
<B>O_RDWR</B>

and any of the other flags listed here:
<DL COMPACT>
<DT><B>O_RDONLY</B>

<DD>
Open the object for read access.
A shared memory object opened in this way can be
<B><A HREF="../man2/mmap.2.html">mmap</A></B>(2)ed

only for read
(<B>PROT_READ</B>)

access.
<DT><B>O_RDWR</B>

<DD>
Open the object for read-write access.
<DT><B>O_CREAT</B>

<DD>
Create the shared memory object if it does not exist.
The user and group ownership of the object are taken
from the corresponding effective IDs of the calling process,


and the object's
permission bits are set according to the low-order 9 bits of
<I>mode</I>,

except that those bits set in the process file mode
creation mask (see
<B><A HREF="../man2/umask.2.html">umask</A></B>(2))

are cleared for the new object.
A set of macro constants which can be used to define
<I>mode</I>

is listed in
<B><A HREF="../man2/open.2.html">open</A></B>(2).

(Symbolic definitions of these constants can be obtained by including
<I>&lt;<A HREF="file:///usr/include/sys/stat.h">sys/stat.h</A>&gt;</I>.)

<DT><DD>
A new shared memory object initially has zero length---the size of the
object can be set using
<B><A HREF="../man2/ftruncate.2.html">ftruncate</A></B>(2).

The newly allocated bytes of a shared memory
object are automatically initialized to 0.
<DT><B>O_EXCL</B>

<DD>
If
<B>O_CREAT</B>

was also specified, and a shared memory object with the given
<I>name</I>

already exists, return an error.
The check for the existence of the object, and its creation if it
does not exist, are performed atomically.
<DT><B>O_TRUNC</B>

<DD>
If the shared memory object already exists, truncate it to zero bytes.
</DL>
<P>

Definitions of these flag values can be obtained by including
<I>&lt;<A HREF="file:///usr/include/fcntl.h">fcntl.h</A>&gt;</I>.

<P>

On successful completion
<B>shm_open</B>()

returns a new file descriptor referring to the shared memory object.
This file descriptor is guaranteed to be the lowest-numbered file descriptor
not previously opened within the process.
The
<B>FD_CLOEXEC</B>

flag (see
<B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2))

is set for the file descriptor.
<P>

The file descriptor is normally used in subsequent calls
to
<B><A HREF="../man2/ftruncate.2.html">ftruncate</A></B>(2)

(for a newly created object) and
<B><A HREF="../man2/mmap.2.html">mmap</A></B>(2).

After a call to
<B><A HREF="../man2/mmap.2.html">mmap</A></B>(2)

the file descriptor may be closed without affecting the memory mapping.
<P>

The operation
of
<B>shm_unlink</B>()

is analogous to
<B><A HREF="../man2/unlink.2.html">unlink</A></B>(2):

it removes a shared memory object name, and, once all processes
have unmapped the object, de-allocates and
destroys the contents of the associated memory region.
After a successful
<B>shm_unlink</B>(),

attempts to
<B>shm_open</B>()

an object with the same
<I>name</I>

fail (unless
<B>O_CREAT</B>

was specified, in which case a new, distinct object is created).
<A NAME="lbAE">&nbsp;</A>
<H2>RETURN VALUE</H2>

On success,
<B>shm_open</B>()

returns a file descriptor (a nonnegative integer).
On failure,
<B>shm_open</B>()

returns -1.
<B>shm_unlink</B>()

returns 0 on success, or -1 on error.
<A NAME="lbAF">&nbsp;</A>
<H2>ERRORS</H2>

On failure,
<I>errno</I>

is set to indicate the cause of the error.
Values which may appear in
<I>errno</I>

include the following:
<DL COMPACT>
<DT><B>EACCES</B>

<DD>
Permission to
<B>shm_unlink</B>()

the shared memory object was denied.
<DT><B>EACCES</B>

<DD>
Permission was denied to
<B>shm_open</B>()

<I>name</I>

in the specified
<I>mode</I>,

or
<B>O_TRUNC</B>

was specified and the caller does not have write permission on the object.
<DT><B>EEXIST</B>

<DD>
Both
<B>O_CREAT</B>

and
<B>O_EXCL</B>

were specified to
<B>shm_open</B>()

and the shared memory object specified by
<I>name</I>

already exists.
<DT><B>EINVAL</B>

<DD>
The
<I>name</I>

argument to
<B>shm_open</B>()

was invalid.
<DT><B>EMFILE</B>

<DD>
The per-process limit on the number of open file descriptors has been reached.
<DT><B>ENAMETOOLONG</B>

<DD>
The length of
<I>name</I>

exceeds
<B>PATH_MAX</B>.

<DT><B>ENFILE</B>

<DD>
The system-wide limit on the total number of open files has been reached.
<DT><B>ENOENT</B>

<DD>
An attempt was made to
<B>shm_open</B>()

a
<I>name</I>

that did not exist, and
<B>O_CREAT</B>

was not specified.
<DT><B>ENOENT</B>

<DD>
An attempt was to made to
<B>shm_unlink</B>()

a
<I>name</I>

that does not exist.
</DL>
<A NAME="lbAG">&nbsp;</A>
<H2>VERSIONS</H2>

These functions are provided in glibc 2.2 and later.
<A NAME="lbAH">&nbsp;</A>
<H2>ATTRIBUTES</H2>

For an explanation of the terms used in this section, see
<B><A HREF="../man7/attributes.7.html">attributes</A></B>(7).

<TABLE BORDER>
<TR VALIGN=top><TD><B>Interface</B></TD><TD><B>Attribute</B></TD><TD><B>Value</B><BR></TD></TR>
<TR VALIGN=top><TD>
<B>shm_open</B>(),

<B>shm_unlink</B>()

</TD><TD>Thread safety</TD><TD>MT-Safe locale<BR></TD></TR>
</TABLE>

<P>
<A NAME="lbAI">&nbsp;</A>
<H2>CONFORMING TO</H2>

POSIX.1-2001, POSIX.1-2008.
<P>

POSIX.1-2001 says that the group ownership of a newly created shared
memory object is set to either the calling process's effective group ID
or &quot;a system default group ID&quot;.
POSIX.1-2008 says that the group ownership
may be set to either the calling process's effective group ID
or, if the object is visible in the filesystem,
the group ID of the parent directory.
<A NAME="lbAJ">&nbsp;</A>
<H2>NOTES</H2>

<P>

POSIX leaves the behavior of the combination of
<B>O_RDONLY</B>

and
<B>O_TRUNC</B>

unspecified.
On Linux, this will successfully truncate an existing
shared memory object---this may not be so on other UNIX systems.
<P>

The POSIX shared memory object implementation on Linux makes use
of a dedicated
<B><A HREF="../man5/tmpfs.5.html">tmpfs</A></B>(5)

filesystem that is normally mounted under
<I>/dev/shm</I>.

<A NAME="lbAK">&nbsp;</A>
<H2>EXAMPLE</H2>

The programs below employ POSIX shared memory and POSIX unnamed semaphores
to exchange a piece of data.
The &quot;bounce&quot; program (which must be run first) raises the case
of a string that is placed into the shared memory by the &quot;send&quot; program.
Once the data has been modified, the &quot;send&quot; program then prints
the contents of the modified shared memory.
An example execution of the two programs is the following:
<P>



$ <B>./pshm_ucase_bounce /myshm &amp;</B>
[1] 270171
$ <B>./pshm_ucase_send /myshm hello</B>
HELLO


<P>

Further detail about these programs is provided below.

<A NAME="lbAL">&nbsp;</A>
<H3>Program source: pshm_ucase.h</H3>

The following header file is included by both programs below.
Its primary purpose is to define a structure that will be imposed
on the memory object that is shared between the two programs.
<P>



#include &lt;<A HREF="file:///usr/include/sys/mman.h">sys/mman.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/fcntl.h">fcntl.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/semaphore.h">semaphore.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/sys/stat.h">sys/stat.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/stdio.h">stdio.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/stdlib.h">stdlib.h</A>&gt;
#include &lt;<A HREF="file:///usr/include/unistd.h">unistd.h</A>&gt;
<P>
#define errExit(msg)    do { perror(msg); exit(EXIT_FAILURE); \
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;while&nbsp;(0)
<P>
#define BUF_SIZE 1024   /* Maximum size for exchanged string */
<P>
/* Define a structure that will be imposed on the shared
<BR>&nbsp;&nbsp;&nbsp;memory&nbsp;object&nbsp;*/
<P>
struct shmbuf {
<BR>&nbsp;&nbsp;&nbsp;&nbsp;sem_t&nbsp;&nbsp;sem1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;POSIX&nbsp;unnamed&nbsp;semaphore&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;sem_t&nbsp;&nbsp;sem2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;POSIX&nbsp;unnamed&nbsp;semaphore&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;cnt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Number&nbsp;of&nbsp;bytes&nbsp;used&nbsp;in&nbsp;'buf'&nbsp;*/
<BR>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;&nbsp;&nbsp;buf[BUF_SIZE];&nbsp;&nbsp;&nbsp;/*&nbsp;Data&nbsp;being&nbsp;transferred&nbsp;*/
};


<P>


<A NAME="lbAM">&nbsp;</A>
<H3>Program source: pshm_ucase_bounce.c</H3>

<P>

The &quot;bounce&quot; program creates a new shared memory object with the name
given in its command-line argument and sizes the object to
match the size of the
<I>shmbuf</I>

structure defined in the header file.
It then maps the object into the process's address space,
and initializes two POSIX semaphores inside the object to 0.
<P>

After the &quot;send&quot; program has posted the first of the semaphores,
the &quot;bounce&quot; program upper cases the data that has been placed
in the memory by the &quot;send&quot; program and then posts the second semaphore
to tell the &quot;send&quot; program that it may now access the shared memory.
<P>



#include &lt;<A HREF="file:///usr/include/ctype.h">ctype.h</A>&gt;
#include &quot;pshm_ucase.h&quot;
<P>
int
main(int argc, char *argv[])
{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;!=&nbsp;2)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;&quot;Usage:&nbsp;%s&nbsp;/shm-path\n&quot;,&nbsp;argv[0]);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(EXIT_FAILURE);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*shmpath&nbsp;=&nbsp;argv[1];
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Create&nbsp;shared&nbsp;memory&nbsp;object&nbsp;and&nbsp;set&nbsp;its&nbsp;size&nbsp;to&nbsp;the&nbsp;size
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;of&nbsp;our&nbsp;structure&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;fd&nbsp;=&nbsp;shm_open(shmpath,&nbsp;O_CREAT&nbsp;|&nbsp;O_EXCL&nbsp;|&nbsp;O_RDWR,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;S_IRUSR&nbsp;|&nbsp;S_IWUSR);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd&nbsp;==&nbsp;-1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errExit(&quot;shm_open&quot;);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(ftruncate(fd,&nbsp;sizeof(struct&nbsp;shmbuf))&nbsp;==&nbsp;-1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errExit(&quot;ftruncate&quot;);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Map&nbsp;the&nbsp;object&nbsp;into&nbsp;the&nbsp;caller's&nbsp;address&nbsp;space&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;shmbuf&nbsp;*shmp&nbsp;=&nbsp;mmap(NULL,&nbsp;sizeof(struct&nbsp;shmbuf),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PROT_READ&nbsp;|&nbsp;PROT_WRITE,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MAP_SHARED,&nbsp;fd,&nbsp;0);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(shmp&nbsp;==&nbsp;MAP_FAILED)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errExit(&quot;mmap&quot;);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Initialize&nbsp;semaphores&nbsp;as&nbsp;process-shared,&nbsp;with&nbsp;value&nbsp;0&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sem_init(&amp;shmp-&gt;sem1,&nbsp;1,&nbsp;0)&nbsp;==&nbsp;-1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errExit(&quot;sem_init-sem1&quot;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sem_init(&amp;shmp-&gt;sem2,&nbsp;1,&nbsp;0)&nbsp;==&nbsp;-1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errExit(&quot;sem_init-sem2&quot;);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Wait&nbsp;for&nbsp;'sem1'&nbsp;to&nbsp;be&nbsp;posted&nbsp;by&nbsp;peer&nbsp;before&nbsp;touching
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shared&nbsp;memory&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sem_wait(&amp;shmp-&gt;sem1)&nbsp;==&nbsp;-1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errExit(&quot;sem_wait&quot;);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Convert&nbsp;data&nbsp;in&nbsp;shared&nbsp;memory&nbsp;into&nbsp;upper&nbsp;case&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;(int&nbsp;j&nbsp;=&nbsp;0;&nbsp;j&nbsp;&lt;&nbsp;shmp-&gt;cnt;&nbsp;j++)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shmp-&gt;buf[j]&nbsp;=&nbsp;toupper((unsigned&nbsp;char)&nbsp;shmp-&gt;buf[j]);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Post&nbsp;'sem2'&nbsp;to&nbsp;tell&nbsp;the&nbsp;to&nbsp;tell&nbsp;peer&nbsp;that&nbsp;it&nbsp;can&nbsp;now
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;access&nbsp;the&nbsp;modified&nbsp;data&nbsp;in&nbsp;shared&nbsp;memory&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sem_post(&amp;shmp-&gt;sem2)&nbsp;==&nbsp;-1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errExit(&quot;sem_post&quot;);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Unlink&nbsp;the&nbsp;shared&nbsp;memory&nbsp;object.&nbsp;Even&nbsp;if&nbsp;the&nbsp;peer&nbsp;process
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;is&nbsp;still&nbsp;using&nbsp;the&nbsp;object,&nbsp;this&nbsp;is&nbsp;okay.&nbsp;The&nbsp;object&nbsp;will
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;be&nbsp;removed&nbsp;only&nbsp;after&nbsp;all&nbsp;open&nbsp;references&nbsp;are&nbsp;closed.&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;shm_unlink(shmpath);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;exit(EXIT_SUCCESS);
}


<P>


<A NAME="lbAN">&nbsp;</A>
<H3>Program source: pshm_ucase_send.c</H3>

<P>

The &quot;send&quot; program takes two command-line arguments:
the pathname of a shared memory object previously created by the &quot;bounce&quot;
program and a string that is to be copied into that object.
<P>

The program opens the shared memory object
and maps the object into its address space.
It then copies the data specified in its second argument
into the shared memory,
and posts the first semaphore,
which tells the &quot;bounce&quot; program that it can now access that data.
After the &quot;bounce&quot; program posts the second semaphore,
the &quot;send&quot; program prints the contents of the shared memory
on standard output.
<P>



#include &lt;<A HREF="file:///usr/include/string.h">string.h</A>&gt;
#include &quot;pshm_ucase.h&quot;
<P>
int
main(int argc, char *argv[])
{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(argc&nbsp;!=&nbsp;3)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;&quot;Usage:&nbsp;%s&nbsp;/shm-path&nbsp;string\n&quot;,&nbsp;argv[0]);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(EXIT_FAILURE);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*shmpath&nbsp;=&nbsp;argv[1];
<BR>&nbsp;&nbsp;&nbsp;&nbsp;char&nbsp;*string&nbsp;=&nbsp;argv[2];
<BR>&nbsp;&nbsp;&nbsp;&nbsp;size_t&nbsp;len&nbsp;=&nbsp;strlen(string);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(len&nbsp;&gt;&nbsp;BUF_SIZE)&nbsp;{
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fprintf(stderr,&nbsp;&quot;String&nbsp;is&nbsp;too&nbsp;long\n&quot;);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;exit(EXIT_FAILURE);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;}
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Open&nbsp;the&nbsp;existing&nbsp;shared&nbsp;memory&nbsp;object&nbsp;and&nbsp;map&nbsp;it
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;into&nbsp;the&nbsp;caller's&nbsp;address&nbsp;space&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;int&nbsp;fd&nbsp;=&nbsp;shm_open(shmpath,&nbsp;O_RDWR,&nbsp;0);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(fd&nbsp;==&nbsp;-1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errExit(&quot;shm_open&quot;);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;struct&nbsp;shmbuf&nbsp;*shmp&nbsp;=&nbsp;mmap(NULL,&nbsp;sizeof(struct&nbsp;shmbuf),
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PROT_READ&nbsp;|&nbsp;PROT_WRITE,
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MAP_SHARED,&nbsp;fd,&nbsp;0);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(shmp&nbsp;==&nbsp;MAP_FAILED)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errExit(&quot;mmap&quot;);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Copy&nbsp;data&nbsp;into&nbsp;the&nbsp;shared&nbsp;memory&nbsp;object&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;shmp-&gt;cnt&nbsp;=&nbsp;len;
<BR>&nbsp;&nbsp;&nbsp;&nbsp;memcpy(&amp;shmp-&gt;buf,&nbsp;string,&nbsp;len);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Tell&nbsp;peer&nbsp;that&nbsp;it&nbsp;can&nbsp;now&nbsp;access&nbsp;shared&nbsp;memory&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sem_post(&amp;shmp-&gt;sem1)&nbsp;==&nbsp;-1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errExit(&quot;sem_post&quot;);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Wait&nbsp;until&nbsp;peer&nbsp;says&nbsp;that&nbsp;it&nbsp;has&nbsp;finished&nbsp;accessing
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;the&nbsp;shared&nbsp;memory&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(sem_wait(&amp;shmp-&gt;sem2)&nbsp;==&nbsp;-1)
<BR>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;errExit(&quot;sem_wait&quot;);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;/*&nbsp;Write&nbsp;modified&nbsp;data&nbsp;in&nbsp;shared&nbsp;memory&nbsp;to&nbsp;standard&nbsp;output&nbsp;*/
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;write(STDOUT_FILENO,&nbsp;&amp;shmp-&gt;buf,&nbsp;len);
<BR>&nbsp;&nbsp;&nbsp;&nbsp;write(STDOUT_FILENO,&nbsp;&quot;\n&quot;,&nbsp;1);
<P>
<BR>&nbsp;&nbsp;&nbsp;&nbsp;exit(EXIT_SUCCESS);
}


<P>

<A NAME="lbAO">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="../man2/close.2.html">close</A></B>(2),

<B><A HREF="../man2/fchmod.2.html">fchmod</A></B>(2),

<B><A HREF="../man2/fchown.2.html">fchown</A></B>(2),

<B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2),

<B><A HREF="../man2/fstat.2.html">fstat</A></B>(2),

<B><A HREF="../man2/ftruncate.2.html">ftruncate</A></B>(2),

<B><A HREF="../man2/memfd_create.2.html">memfd_create</A></B>(2),

<B><A HREF="../man2/mmap.2.html">mmap</A></B>(2),

<B><A HREF="../man2/open.2.html">open</A></B>(2),

<B><A HREF="../man2/umask.2.html">umask</A></B>(2),

<B><A HREF="../man7/shm_overview.7.html">shm_overview</A></B>(7)

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">RETURN VALUE</A><DD>
<DT><A HREF="#lbAF">ERRORS</A><DD>
<DT><A HREF="#lbAG">VERSIONS</A><DD>
<DT><A HREF="#lbAH">ATTRIBUTES</A><DD>
<DT><A HREF="#lbAI">CONFORMING TO</A><DD>
<DT><A HREF="#lbAJ">NOTES</A><DD>
<DT><A HREF="#lbAK">EXAMPLE</A><DD>
<DL>
<DT><A HREF="#lbAL">Program source: pshm_ucase.h</A><DD>
<DT><A HREF="#lbAM">Program source: pshm_ucase_bounce.c</A><DD>
<DT><A HREF="#lbAN">Program source: pshm_ucase_send.c</A><DD>
</DL>
<DT><A HREF="#lbAO">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 03:53:30 GMT, April 20, 2020
</BODY>
</HTML>
