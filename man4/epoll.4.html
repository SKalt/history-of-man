<!--
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of EPOLL</TITLE>
</HEAD><BODY>
<H1>EPOLL</H1>
Section: Linux Programmer's Manual (7)<BR>Updated: 2007-06-22<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

epoll - I/O event notification facility
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<B>#include &lt;<A HREF="file:///usr/include/sys/epoll.h">sys/epoll.h</A>&gt;</B>

<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

<B>epoll</B>

is a variant of
<B><A HREF="../man2/poll.2.html">poll</A></B>(2)

that can be used either as an edge-triggered or a level-triggered
interface and scales well to large numbers of watched file descriptors.
Three system calls are provided to
set up and control an
<B>epoll</B>

set:
<B><A HREF="../man2/epoll_create.2.html">epoll_create</A></B>(2),

<B><A HREF="../man2/epoll_ctl.2.html">epoll_ctl</A></B>(2),

<B><A HREF="../man2/epoll_wait.2.html">epoll_wait</A></B>(2).

<P>
An
<B>epoll</B>

set is connected to a file descriptor created by
<B><A HREF="../man2/epoll_create.2.html">epoll_create</A></B>(2).

Interest for certain file descriptors is then registered via
<B><A HREF="../man2/epoll_ctl.2.html">epoll_ctl</A></B>(2).

Finally, the actual wait is started by
<B><A HREF="../man2/epoll_wait.2.html">epoll_wait</A></B>(2).

<A NAME="lbAE">&nbsp;</A>
<H3>Level-Triggered and Edge-Triggered</H3>

The
<B>epoll</B>

event distribution interface is able to behave both as edge-triggered
(ET) and level-triggered (LT).
The difference between the two mechanisms
can be described as follows.
Suppose that
this scenario happens :
<DL COMPACT>
<DT>1.<DD>
The file descriptor that represents the read side of a pipe
(<I>rfd</I>)

is added inside the
<B>epoll</B>

device.
<DT>2.<DD>
A pipe writer writes 2 kB of data on the write side of the pipe.
<DT>3.<DD>
A call to
<B><A HREF="../man2/epoll_wait.2.html">epoll_wait</A></B>(2)

is done that will return
<I>rfd</I>

as a ready file descriptor.
<DT>4.<DD>
The pipe reader reads 1 kB of data from
<I>rfd</I>.

<DT>5.<DD>
A call to
<B><A HREF="../man2/epoll_wait.2.html">epoll_wait</A></B>(2)

is done.
</DL>
<P>

If the
<I>rfd</I>

file descriptor has been added to the
<B>epoll</B>

interface using the
<B>EPOLLET</B>

flag, the call to
<B><A HREF="../man2/epoll_wait.2.html">epoll_wait</A></B>(2)

done in step
<B>5</B>

will probably hang despite the available data still present in the file
input buffer;
meanwhile the remote peer might be expecting a response based on the
data it already sent.
The reason for this is that edge-triggered mode only
delivers events when changes occur on the monitored file descriptor.
So, in step
<B>5</B>

the caller might end up waiting for some data that is already present inside
the input buffer.
In the above example, an event on
<I>rfd</I>

will be generated because of the write done in
<B>2</B>

and the event is consumed in
<B>3</B>.

Since the read operation done in
<B>4</B>

does not consume the whole buffer data, the call to
<B><A HREF="../man2/epoll_wait.2.html">epoll_wait</A></B>(2)

done in step
<B>5</B>

might block indefinitely.
<P>
An application that employs the
<B>EPOLLET</B>

flag (edge-triggered)
should use non-blocking file descriptors to avoid having a blocking
read or write starve a task that is handling multiple file descriptors.
The suggested way to use
<B>epoll</B>

as an edge-triggered
(<B>EPOLLET</B>)

interface is as follows:
<DL COMPACT><DT><DD>
<DL COMPACT>
<DT><B>i</B>

<DD>
with non-blocking file descriptors
<DT><B>ii</B>

<DD>
by waiting for an event only after
<B><A HREF="../man2/read.2.html">read</A></B>(2)

or
<B><A HREF="../man2/write.2.html">write</A></B>(2)

return
<B>EAGAIN</B>.

</DL>
</DL>

<P>

By contrast, when used as a level-triggered interface,
<B>epoll</B>

is simply a faster
<B><A HREF="../man2/poll.2.html">poll</A></B>(2),

and can be used wherever the latter is used since it shares the
same semantics.
<P>
Since even with the edge-triggered
<B>epoll</B>

multiple events can be generated upon receipt of multiple chunks of data,
the caller has the option to specify the
<B>EPOLLONESHOT</B>

flag, to tell
<B>epoll</B>

to disable the associated file descriptor after the receipt of an event with
<B><A HREF="../man2/epoll_wait.2.html">epoll_wait</A></B>(2).

When the
<B>EPOLLONESHOT</B>

flag is specified,
it is the caller's responsibility to rearm the file descriptor using
<B><A HREF="../man2/epoll_ctl.2.html">epoll_ctl</A></B>(2)

with
<B>EPOLL_CTL_MOD</B>.

<A NAME="lbAF">&nbsp;</A>
<H3>Example for Suggested Usage</H3>

While the usage of
<B>epoll</B>

when employed as a level-triggered interface does have the same
semantics as
<B><A HREF="../man2/poll.2.html">poll</A></B>(2),

the edge-triggered usage requires more clarification to avoid stalls
in the application event loop.
In this example, listener is a
non-blocking socket on which
<B><A HREF="../man2/listen.2.html">listen</A></B>(2)

has been called.
The function do_use_fd() uses the new ready
file descriptor until
<B>EAGAIN</B>

is returned by either
<B><A HREF="../man2/read.2.html">read</A></B>(2)

or
<B><A HREF="../man2/write.2.html">write</A></B>(2).

An event-driven state machine application should, after having received
<B>EAGAIN</B>,

record its current state so that at the next call to do_use_fd()
it will continue to
<B><A HREF="../man2/read.2.html">read</A></B>(2)

or
<B><A HREF="../man2/write.2.html">write</A></B>(2)

from where it stopped before.
<P>
<PRE>
struct epoll_event ev, *events;

for (;;) {
    nfds = epoll_wait(kdpfd, events, maxevents, -1);

    for (n = 0; n &lt; nfds; ++n) {
        if (events[n].data.fd == listener) {
            client = accept(listener, (struct sockaddr *) &amp;local,
                            &amp;addrlen);
            if (client &lt; 0){
                perror(&quot;accept&quot;);
                continue;
            }
            setnonblocking(client);
            ev.events = EPOLLIN | EPOLLET;
            ev.data.fd = client;
            if (epoll_ctl(kdpfd, EPOLL_CTL_ADD, client, &amp;ev) &lt; 0) {
                fprintf(stderr, &quot;epoll set insertion error: fd=%d\n&quot;,
                        client);
                return -1;
            }
        } else {
            do_use_fd(events[n].data.fd);
        }
    }
}
</PRE>

<P>
When used as an edge-triggered interface, for performance reasons, it is
possible to add the file descriptor inside the epoll interface
(<B>EPOLL_CTL_ADD</B>)

once by specifying
(<B>EPOLLIN</B>|<B>EPOLLOUT</B>).

This allows you to avoid
continuously switching between
<B>EPOLLIN</B>

and
<B>EPOLLOUT</B>

calling
<B><A HREF="../man2/epoll_ctl.2.html">epoll_ctl</A></B>(2)

with
<B>EPOLL_CTL_MOD</B>.

<A NAME="lbAG">&nbsp;</A>
<H3>Questions and Answers</H3>

<DL COMPACT>
<DT><B>Q1</B>

<DD>
What happens if you add the same file descriptor to an epoll set twice?
<DT><B>A1</B>

<DD>
You will probably get
<B>EEXIST</B>.

However, it is possible that two
threads may add the same file descriptor twice.
This is a harmless condition.
<DT><B>Q2</B>

<DD>
Can two
<B>epoll</B>

sets wait for the same file descriptor?
If so, are events reported to both
<B>epoll</B>

file descriptors?
<DT><B>A2</B>

<DD>
Yes, and events would be reported to both.
However, it is not recommended.
<DT><B>Q3</B>

<DD>
Is the
<B>epoll</B>

file descriptor itself poll/epoll/selectable?
<DT><B>A3</B>

<DD>
Yes.
<DT><B>Q4</B>

<DD>
What happens if the
<B>epoll</B>

file descriptor is put into its own file descriptor set?
<DT><B>A4</B>

<DD>
It will fail.
However, you can add an
<B>epoll</B>

file descriptor inside another epoll file descriptor set.
<DT><B>Q5</B>

<DD>
Can I send the
<B>epoll</B>

file descriptor over a unix-socket to another process?
<DT><B>A5</B>

<DD>
No.
<DT><B>Q6</B>

<DD>
Will closing a file descriptor cause it to be removed from all
<B>epoll</B>

sets automatically?
<DT><B>A6</B>

<DD>
Yes.
<DT><B>Q7</B>

<DD>
If more than one event occurs between
<B><A HREF="../man2/epoll_wait.2.html">epoll_wait</A></B>(2)

calls, are they combined or reported separately?
<DT><B>A7</B>

<DD>
They will be combined.
<DT><B>Q8</B>

<DD>
Does an operation on a file descriptor affect the
already collected but not yet reported events?
<DT><B>A8</B>

<DD>
You can do two operations on an existing file descriptor.
Remove would be meaningless for
this case.
Modify will re-read available I/O.
<DT><B>Q9</B>

<DD>
Do I need to continuously read/write a file descriptor
until
<B>EAGAIN</B>

when using the
<B>EPOLLET</B>

flag (edge-triggered behavior) ?
<DT><B>A9</B>

<DD>
No you don't.
Receiving an event from
<B><A HREF="../man2/epoll_wait.2.html">epoll_wait</A></B>(2)

should suggest to you that such file descriptor is ready
for the requested I/O operation.
You have simply to consider it ready until you will receive the
next
<B>EAGAIN</B>.

When and how you will use such file descriptor is entirely up
to you.
Also, the condition that the read/write I/O space is exhausted can
be detected by checking the amount of data read from / written to the target
file descriptor.
For example, if you call
<B><A HREF="../man2/read.2.html">read</A></B>(2)

by asking to read a certain amount of data and
<B><A HREF="../man2/read.2.html">read</A></B>(2)

returns a lower number of bytes,
you can be sure of having exhausted the read
I/O space for such file descriptor.
The same is true when writing using
<B><A HREF="../man2/write.2.html">write</A></B>(2).

</DL>
<A NAME="lbAH">&nbsp;</A>
<H3>Possible Pitfalls and Ways to Avoid Them</H3>

<DL COMPACT>
<DT><B>o Starvation (edge-triggered)</B>

<DD>
</DL>
<P>

If there is a large amount of I/O space,
it is possible that by trying to drain
it the other files will not get processed causing starvation.
(This problem is not specific to
<B>epoll</B>.)

<P>

The solution is to maintain a ready list
and mark the file descriptor as ready
in its associated data structure, thereby allowing the application to
remember which files need to be processed but still round robin amongst
all the ready files.
This also supports ignoring subsequent events you
receive for file descriptors that are already ready.
<DL COMPACT>
<DT><B>o If using an event cache...</B>

<DD>
</DL>
<P>

If you use an event cache or store all the file descriptors returned from
<B><A HREF="../man2/epoll_wait.2.html">epoll_wait</A></B>(2),

then make sure to provide a way to mark
its closure dynamically (i.e., caused by
a previous event's processing).
Suppose you receive 100 events from
<B><A HREF="../man2/epoll_wait.2.html">epoll_wait</A></B>(2),

and in event #47 a condition causes event #13 to be closed.
If you remove the structure and
<B><A HREF="../man2/close.2.html">close</A></B>(2)

the file descriptor for event #13, then your
event cache might still say there are events waiting for that
file descriptor causing confusion.
<P>

One solution for this is to call, during the processing of event 47,
<B>epoll_ctl</B>(<B>EPOLL_CTL_DEL</B>)

to delete file descriptor 13 and
<B><A HREF="../man2/close.2.html">close</A></B>(2),

then mark its associated
data structure as removed and link it to a cleanup list.
If you find another
event for file descriptor 13 in your batch processing,
you will discover the file descriptor had been
previously removed and there will be no confusion.
<A NAME="lbAI">&nbsp;</A>
<H2>VERSIONS</H2>

The
<B>epoll</B>

API was introduced in Linux kernel 2.5.44.
Its interface should be finalized in Linux kernel 2.5.66.
<A NAME="lbAJ">&nbsp;</A>
<H2>CONFORMING TO</H2>

The epoll API is Linux-specific.
Some other systems provide similar
mechanisms, for example, FreeBSD has
<I>kqueue</I>,

and Solaris has
<I>/dev/poll</I>.

<A NAME="lbAK">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="../man2/epoll_create.2.html">epoll_create</A></B>(2),

<B><A HREF="../man2/epoll_ctl.2.html">epoll_ctl</A></B>(2),

<B><A HREF="../man2/epoll_wait.2.html">epoll_wait</A></B>(2)



<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAE">Level-Triggered and Edge-Triggered</A><DD>
<DT><A HREF="#lbAF">Example for Suggested Usage</A><DD>
<DT><A HREF="#lbAG">Questions and Answers</A><DD>
<DT><A HREF="#lbAH">Possible Pitfalls and Ways to Avoid Them</A><DD>
</DL>
<DT><A HREF="#lbAI">VERSIONS</A><DD>
<DT><A HREF="#lbAJ">CONFORMING TO</A><DD>
<DT><A HREF="#lbAK">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 02:51:13 GMT, April 20, 2020
</BODY>
</HTML>
