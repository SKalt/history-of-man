<!--
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of ELF</TITLE>
</HEAD><BODY>
<H1>ELF</H1>
Section: File Formats (5)<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>
<BR>BSD mandoc<BR>
<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>



<B>elf</B>

 - format of ELF executable binary files

<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>


Fd #include &lt;<A HREF="file:///usr/include/elf.h">elf.h</A>&gt;

<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

The header file

Aq Pa elf.h

defines the format of ELF executable binary files.
Amongst these files are
normal executable files, relocatable object files, core files and shared
libraries.
<P>

An executable file using the ELF file format consists of an ELF header,
followed by a program header table or a section header table, or both.
The ELF header is always at offset zero of the file.
The program header
table and the section header table's offset in the file are defined in the
ELF header.
The two tables describe the rest of the particularities of
the file.
<P>
























This header file describes the above mentioned headers as C structures
and also includes structures for dynamic sections, relocation sections and
symbol tables.
<P>

The following types are used for N-bit architectures (N=32,64,
ElfN stands for Elf32 or Elf64, uintN_t stands for uint32_t or uint64_t):

<BLOCKQUOTE>
<PRE>
ElfN_Addr       Unsigned program address, uintN_t
ElfN_Off        Unsigned file offset, uintN_t
ElfN_Section    Unsigned section index, uint16_t
ElfN_Versym     Unsigned version symbol information, uint16_t
Elf_Byte        unsigned char
ElfN_Half       uint16_t
ElfN_Sword      int32_t
ElfN_Word       uint32_t
ElfN_Sxword     int64_t
ElfN_Xword      uint64_t
</PRE>
</BLOCKQUOTE>

<P>

(Note: The *BSD terminology is a bit different. There Elf64_Half is
twice as large as Elf32_Half, and Elf64Quarter is used for uint16_t.
In order to avoid confusion these types are replaced by explicit ones
in the below.)
<P>

All data structures that the file format defines follow the
``natural''

size and alignment guidelines for the relevant class.
If necessary,
data structures contain explicit padding to ensure 4-byte alignment
for 4-byte objects, to force structure sizes to a multiple of 4, etc.
<P>

The ELF header is described by the type Elf32_Ehdr or Elf64_Ehdr:

<BLOCKQUOTE>
<PRE>
#define EI_NIDENT 16

typedef struct {
        unsigned char  e_ident[EI_NIDENT];
        uint16_t       e_type;
        uint16_t       e_machine;
        uint32_t       e_version;
        ElfN_Addr      e_entry;
        ElfN_Off       e_phoff;
        ElfN_Off       e_shoff;
        uint32_t       e_flags;
        uint16_t       e_ehsize;
        uint16_t       e_phentsize;
        uint16_t       e_phnum;
        uint16_t       e_shentsize;
        uint16_t       e_shnum;
        uint16_t       e_shstrndx;
} ElfN_Ehdr;
</PRE>
</BLOCKQUOTE>

<P>

The fields have the following meanings:
<DL COMPACT>
<P>

<DT><B>e_ident</B>


<DD>
This array of bytes specifies to interpret the file,
independent of the processor or the file's remaining contents.
Within this array everything is named by macros, which start with
the prefix
<B>EI_</B>

and may contain values which start with the prefix
<B>ELF</B>

 
The following macros are defined:
<DL COMPACT>
<P>

<DT><B>EI_MAG0</B>


<DD>
The first byte of the magic number.
It must be filled with
<B>ELFMAG0</B>

 
(0: 0x7f)
<DT><B>EI_MAG1</B>


<DD>
The second byte of the magic number.
It must be filled with
<B>ELFMAG1</B>

 
(1: 'E')
<DT><B>EI_MAG2</B>


<DD>
The third byte of the magic number.
It must be filled with
<B>ELFMAG2</B>

 
(2: 'L')
<DT><B>EI_MAG3</B>


<DD>
The fourth byte of the magic number.
It must be filled with
<B>ELFMAG3</B>

 
(3: 'F')
<DT><B>EI_CLASS</B>


<DD>
The fifth byte identifies the architecture for this binary:
<P>

<DL COMPACT>
<P>

<DT><B>ELFCLASSNONE</B>


<DD>
This class is invalid.
<DT><B>ELFCLASS32</B>


<DD>
This defines the 32-bit architecture.
It supports machines with files
and virtual address spaces up to 4 Gigabytes.
<DT><B>ELFCLASS64</B>


<DD>
This defines the 64-bit architecture.
</DL>
<P>

<DT><B>EI_DATA</B>


<DD>
The sixth byte specifies the data encoding of the processor-specific
data in the file.
Currently these encodings are supported:
<P>

<DL COMPACT>
<P>

<DT><B>ELFDATANONE</B>


<DD>
Unknown data format.
<DT><B>ELFDATA2LSB</B>


<DD>
Two's complement, little-endian.
<DT><B>ELFDATA2MSB</B>


<DD>
Two's complement, big-endian.
</DL>
<P>

<DT><B>EI_VERSION</B>


<DD>
The version number of the ELF specification:
<P>

<DL COMPACT>
<P>

<DT><B>EV_NONE</B>


<DD>
Invalid version.
<DT><B>EV_CURRENT</B>


<DD>
Current version.
</DL>
<P>

<DT><B>EI_OSABI</B>


<DD>
This byte identifies the operating system
and ABI to which the object is targeted.
Some fields in other ELF structures have flags
and values that have platform specific meanings;
the interpretation of those fields is determined by the value of this byte.
E.g.:
<P>

<DL COMPACT>
<P>

<DT><B>ELFOSABI_SYSV</B>


<DD>
UNIX System V ABI.


<DT><B>ELFOSABI_HPUX</B>


<DD>
HP-UX ABI.

<DT><B>ELFOSABI_NETBSD</B>


<DD>
NetBSD ABI.

<DT><B>ELFOSABI_LINUX</B>


<DD>
Linux ABI.







<DT><B>ELFOSABI_SOLARIS</B>


<DD>
Solaris ABI.





<DT><B>ELFOSABI_IRIX</B>


<DD>
IRIX ABI.

<DT><B>ELFOSABI_FREEBSD</B>


<DD>
FreeBSD ABI.

<DT><B>ELFOSABI_TRU64</B>


<DD>
TRU64 UNIX ABI.





<DT><B>ELFOSABI_ARM</B>


<DD>
ARM architecture ABI.

<DT><B>ELFOSABI_STANDALONE</B>


<DD>
Stand-alone (embedded) ABI.

</DL>
<P>

<DT><B>EI_ABIVERSION</B>


<DD>
This byte identifies the version of the ABI
to which the object is targeted.
This field is used to distinguish among incompatible versions of an ABI.
The interpretation of this version number
is dependent on the ABI identified by the EI_OSABI field.
Applications conforming to this specification use the value 0.
<DT><B>EI_PAD</B>


<DD>
Start of padding.
These bytes are reserved and set to zero.
Programs
which read them should ignore them.
The value for EI_PAD will change in
the future if currently unused bytes are given meanings.
<DT><B>EI_BRAND</B>


<DD>
Start of architecture identification.
<DT><B>EI_NIDENT</B>


<DD>
The size of the e_ident array.
</DL>
<P>

<P>

<DT><B>e_type</B>


<DD>
This member of the structure identifies the object file type:
<P>

<DL COMPACT>
<P>

<DT><B>ET_NONE</B>


<DD>
An unknown type.
<DT><B>ET_REL</B>


<DD>
A relocatable file.
<DT><B>ET_EXEC</B>


<DD>
An executable file.
<DT><B>ET_DYN</B>


<DD>
A shared object.
<DT><B>ET_CORE</B>


<DD>
A core file.
</DL>
<P>

<P>

<DT><B>e_machine</B>


<DD>
This member specifies the required architecture for an individual file.
E.g.:
<P>

<DL COMPACT>
<P>

<DT><B>EM_NONE</B>


<DD>
An unknown machine.

<DT><B>EM_M32</B>


<DD>
AT&amp;T WE 32100.

<DT><B>EM_SPARC</B>


<DD>
Sun Microsystems SPARC.

<DT><B>EM_386</B>


<DD>
Intel 80386.

<DT><B>EM_68K</B>


<DD>
Motorola 68000.

<DT><B>EM_88K</B>


<DD>
Motorola 88000.




<DT><B>EM_860</B>


<DD>
Intel 80860.

<DT><B>EM_MIPS</B>


<DD>
MIPS RS3000 (big-endian only).








<DT><B>EM_PARISC</B>


<DD>
HPPA.

<DT><B>EM_SPARC32PLUS</B>


<DD>
SPARC with enhanced instruction set.

<DT><B>EM_PPC</B>


<DD>
PowerPC.







<DT><B>EM_SPARCV9</B>


<DD>
SPARC v9 64-bit.





<DT><B>EM_VAX</B>


<DD>
DEC Vax.







</DL>
<P>

<P>

<DT><B>e_version</B>


<DD>
This member identifies the file version:
<P>

<DL COMPACT>
<P>

<DT><B>EV_NONE</B>


<DD>
Invalid version.
<DT><B>EV_CURRENT</B>


<DD>
Current version.
</DL>
<P>

<DT><B>e_entry</B>


<DD>
This member gives the virtual address to which the system first transfers
control, thus starting the process.
If the file has no associated entry
point, this member holds zero.
<DT><B>e_phoff</B>


<DD>
This member holds the program header table's file offset in bytes.
If
the file has no program header table, this member holds zero.
<DT><B>e_shoff</B>


<DD>
This member holds the section header table's file offset in bytes.
If the
file has no section header table this member holds zero.
<DT><B>e_flags</B>


<DD>
This member holds processor-specific flags associated with the file.
Flag names take the form EF_`machine_flag'.
Currently no flags have been defined.
<DT><B>e_ehsize</B>


<DD>
This member holds the ELF header's size in bytes.
<DT><B>e_phentsize</B>


<DD>
This member holds the size in bytes of one entry in the file's program header
table; all entries are the same size.
<DT><B>e_phnum</B>


<DD>
This member holds the number of entries in the program header
table.
Thus the product of
<B>e_phentsize</B>

and
<B>e_phnum</B>

gives the table's size
in bytes.
If a file has no program header,
<B>e_phnum</B>

holds the value zero.
<DT><B>e_shentsize</B>


<DD>
This member holds a sections header's size in bytes.
A section header is one
entry in the section header table; all entries are the same size.
<DT><B>e_shnum</B>


<DD>
This member holds the number of entries in the section header table.
Thus
the product of
<B>e_shentsize</B>

and
<B>e_shnum</B>

gives the section header table's size in bytes.
If a file has no section
header table,
<B>e_shnum</B>

holds the value of zero.
<DT><B>e_shstrndx</B>


<DD>
This member holds the section header table index of the entry associated
with the section name string table.
If the file has no section name string
table, this member holds the value
<B>SHN_UNDEF</B>

 
<DL COMPACT>
<P>

<DT><B>SHN_UNDEF</B>


<DD>
This value marks an undefined, missing, irrelevant, or otherwise meaningless
section reference.
For example, a symbol
``defined''

relative to section number
<B>SHN_UNDEF</B>

is an undefined symbol.
<DT><B>SHN_LORESERVE</B>


<DD>
This value specifies the lower bound of the range of reserved indices.
<DT><B>SHN_LOPROC</B>


<DD>
Values greater than or equal to
<B>SHN_HIPROC</B>

are reserved for processor-specific semantics.
<DT><B>SHN_HIPROC</B>


<DD>
Values less than or equal to
<B>SHN_LOPROC</B>

are reserved for processor-specific semantics.
<DT><B>SHN_ABS</B>


<DD>
This value specifies absolute values for the corresponding reference.
For
example, symbols defined relative to section number
<B>SHN_ABS</B>

have absolute values and are not affected by relocation.
<DT><B>SHN_COMMON</B>


<DD>
Symbols defined relative to this section are common symbols, such as Fortran
COMMON or unallocated C external variables.
<DT><B>SHN_HIRESERVE</B>


<DD>
This value specifies the upper bound of the range of reserved
indices between
<B>SHN_LORESERVE</B>

and
<B>SHN_HIRESERVE</B>

 
inclusive; the values do
not reference the section header table.
That is, the section header table
does
<I>not</I>

contain entries for the reserved indices.
</DL>
<P>

</DL>
<P>

<P>

An executable or shared object file's program header table is an array of
structures, each describing a segment or other information the system needs
to prepare the program for execution.
An object file
<I>segment</I>

contains one or more
<I>sections</I>

 
Program headers are meaningful only for executable and shared object files.
A file specifies its own program header size with the ELF header's
<B>e_phentsize</B>

and
<B>e_phnum</B>

members.
The ELF program header is described by the type Elf32_Phdr or Elf64_Phdr
depending on the architecture:

<BLOCKQUOTE>
<PRE>
typedef struct {
        uint32_t        p_type;
        Elf32_Off       p_offset;
        Elf32_Addr      p_vaddr;
        Elf32_Addr      p_paddr;
        uint32_t        p_filesz;
        uint32_t        p_memsz;
        uint32_t        p_flags;
        uint32_t        p_align;
} Elf32_Phdr;
</PRE>
</BLOCKQUOTE>


<BLOCKQUOTE>
<PRE>
typedef struct {
        uint32_t        p_type;
        uint32_t        p_flags;
        Elf64_Off       p_offset;
        Elf64_Addr      p_vaddr;
        Elf64_Addr      p_paddr;
        uint64_t        p_filesz;
        uint64_t        p_memsz;
        uint64_t        p_align;
} Elf64_Phdr;
</PRE>
</BLOCKQUOTE>

<P>

The main difference between the 32-bit and the 64-bit program header lies
in the location of the
<B>p_flags</B>

member in the total struct.
<DL COMPACT>
<P>

<DT><B>p_type</B>


<DD>
This member of the Phdr struct tells what kind of segment this array
element describes or how to interpret the array element's information.
<DL COMPACT>
<P>

<DT><B>PT_NULL</B>


<DD>
The array element is unused and the other members' values are undefined.
This lets the program header have ignored entries.
<DT><B>PT_LOAD</B>


<DD>
The array element specifies a loadable segment, described by
<B>p_filesz</B>

and
<B>p_memsz</B>

 
The bytes from the file are mapped to the beginning of the memory
segment.
If the segment's memory size
(<B>p_memsz</B>

)

is larger than the file size
(<B>p_filesz</B>

)

 
the
``extra''

bytes are defined to hold the value 0 and to follow the segment's
initialized area.
The file size may not be larger than the memory size.
Loadable segment entries in the program header table appear in ascending
order, sorted on the
<B>p_vaddr</B>

member.
<DT><B>PT_DYNAMIC</B>


<DD>
The array element specifies dynamic linking information.
<DT><B>PT_INTERP</B>


<DD>
The array element specifies the location and size of a null-terminated
path name to invoke as an interpreter.
This segment type is meaningful
only for executable files (though it may occur for shared objects).
However it may not occur more than once in a file.
If it is present, it must precede any loadable segment entry.
<DT><B>PT_NOTE</B>


<DD>
The array element specifies the location and size for auxiliary information.
<DT><B>PT_SHLIB</B>


<DD>
This segment type is reserved but has unspecified semantics.
Programs that
contain an array element of this type do not conform to the ABI.
<DT><B>PT_PHDR</B>


<DD>
The array element, if present, specifies the location and size of the program
header table itself, both in the file and in the memory image of the program.
This segment type may not occur more than once in a file.
Moreover, it may
only occur if the program header table is part of the memory image of the
program.
If it is present, it must precede any loadable segment entry.
<DT><B>PT_LOPROC</B>


<DD>
Values greater than or equal to
<B>PT_HIPROC</B>

are reserved for processor-specific semantics.
<DT><B>PT_HIPROC</B>


<DD>
Values less than or equal to
<B>PT_LOPROC</B>

are reserved for processor-specific semantics.
</DL>
<P>

<P>

<DT><B>p_offset</B>


<DD>
This member holds the offset from the beginning of the file at which
the first byte of the segment resides.
<DT><B>p_vaddr</B>


<DD>
This member holds the virtual address at which the first byte of the
segment resides in memory.
<DT><B>p_paddr</B>


<DD>
On systems for which physical addressing is relevant, this member is
reserved for the segment's physical address.
Under
BSD this member is
not used and must be zero.
<DT><B>p_filesz</B>


<DD>
This member holds the number of bytes in the file image of the segment.
It may be zero.
<DT><B>p_memsz</B>


<DD>
This member holds the number of bytes in the memory image of the segment.
It may be zero.
<DT><B>p_flags</B>


<DD>
This member holds flags relevant to the segment:
<P>

<DL COMPACT>
<P>

<DT><B>PF_X</B>


<DD>
An executable segment.
<DT><B>PF_W</B>


<DD>
A writable segment.
<DT><B>PF_R</B>


<DD>
A readable segment.
</DL>
<P>

<P>

A text segment commonly has the flags
<B>PF_X</B>

and
<B>PF_R</B>

 
A data segment commonly has
<B>PF_X</B>

 
<B>PF_W</B>

and
<B>PF_R</B>

 
<DT><B>p_align</B>


<DD>
This member holds the value to which the segments are aligned in memory
and in the file.
Loadable process segments must have congruent values for
<B>p_vaddr</B>

and
<B>p_offset</B>

 
modulo the page size.
Values of zero and one mean no alignment is required.
Otherwise,
<B>p_align</B>

should be a positive, integral power of two, and
<B>p_vaddr</B>

should equal
<B>p_offset</B>

 
modulo
<B>p_align</B>

 
</DL>
<P>

<P>

A file's section header table lets one locate all the file's sections.
The
section header table is an array of Elf32_Shdr or Elf64_Shdr structures.
The
ELF header's
<B>e_shoff</B>

member gives the byte offset from the beginning of the file to the section
header table.
<B>e_shnum</B>

holds the number of entries the section header table contains.
<B>e_shentsize</B>

holds the size in bytes of each entry.
<P>

A section header table index is a subscript into this array.
Some section
header table indices are reserved.
An object file does not have sections for
these special indices:
<DL COMPACT>
<P>

<DT><B>SHN_UNDEF</B>


<DD>
This value marks an undefined, missing, irrelevant or otherwise meaningless
section reference.
<DT><B>SHN_LORESERVE</B>


<DD>
This value specifies the lower bound of the range of reserved indices.
<DT><B>SHN_LOPROC</B>


<DD>
Values greater than or equal to
<B>SHN_HIPROC</B>

are reserved for processor-specific semantics.
<DT><B>SHN_HIPROC</B>


<DD>
Values less than or equal to
<B>SHN_LOPROC</B>

are reserved for processor-specific semantics.
<DT><B>SHN_ABS</B>


<DD>
This value specifies the absolute value for the corresponding reference.
For
example, a symbol defined relative to section number
<B>SHN_ABS</B>

has an absolute value and is not affected by relocation.
<DT><B>SHN_COMMON</B>


<DD>
Symbols defined relative to this section are common symbols, such as FORTRAN
COMMON or unallocated C external variables.
<DT><B>SHN_HIRESERVE</B>


<DD>
This value specifies the upper bound of the range of reserved indices.
The
system reserves indices between
<B>SHN_LORESERVE</B>

and
<B>SHN_HIRESERVE</B>

 
inclusive.
The section header table does not contain entries for the
reserved indices.
</DL>
<P>

<P>

The section header has the following structure:

<BLOCKQUOTE>
<PRE>
typedef struct {
        uint32_t        sh_name;
        uint32_t        sh_type;
        uint32_t        sh_flags;
        Elf32_Addr      sh_addr;
        Elf32_Off       sh_offset;
        uint32_t        sh_size;
        uint32_t        sh_link;
        uint32_t        sh_info;
        uint32_t        sh_addralign;
        uint32_t        sh_entsize;
} Elf32_Shdr;
</PRE>
</BLOCKQUOTE>


<BLOCKQUOTE>
<PRE>
typedef struct {
        uint32_t        sh_name;
        uint32_t        sh_type;
        uint64_t        sh_flags;
        Elf64_Addr      sh_addr;
        Elf64_Off       sh_offset;
        uint64_t        sh_size;
        uint32_t        sh_link;
        uint32_t        sh_info;
        uint64_t        sh_addralign;
        uint64_t        sh_entsize;
} Elf64_Shdr;
</PRE>
</BLOCKQUOTE>

<DL COMPACT>
<P>

<DT><B>sh_name</B>


<DD>
This member specifies the name of the section.
Its value is an index
into the section header string table section, giving the location of
a null-terminated string.
<DT><B>sh_type</B>


<DD>
This member categorizes the section's contents and semantics.
<DL COMPACT>
<P>

<DT><B>SHT_NULL</B>


<DD>
This value marks the section header as inactive.
It does not
have an associated section.
Other members of the section header
have undefined values.
<DT><B>SHT_PROGBITS</B>


<DD>
This section holds information defined by the program, whose
format and meaning are determined solely by the program.
<DT><B>SHT_SYMTAB</B>


<DD>
This section holds a symbol table.
Typically,
<B>SHT_SYMTAB</B>

provides symbols for link editing, though it may also be used
for dynamic linking.
As a complete symbol table, it may contain
many symbols unnecessary for dynamic linking.
An object file can
also contain a
<B>SHN_DYNSYM</B>

section.
<DT><B>SHT_STRTAB</B>


<DD>
This section holds a string table.
An object file may have multiple
string table sections.
<DT><B>SHT_RELA</B>


<DD>
This section holds relocation entries with explicit addends, such
as type
<B>Elf32_Rela</B>

for the 32-bit class of object files.
An object may have multiple
relocation sections.
<DT><B>SHT_HASH</B>


<DD>
This section holds a symbol hash table.
An object participating in
dynamic linking must contain a symbol hash table.
An object file may
have only one hash table.
<DT><B>SHT_DYNAMIC</B>


<DD>
This section holds information for dynamic linking.
An object file may
have only one dynamic section.
<DT><B>SHT_NOTE</B>


<DD>
This section holds information that marks the file in some way.
<DT><B>SHT_NOBITS</B>


<DD>
A section of this type occupies no space in the file but otherwise
resembles
<B>SHN_PROGBITS</B>

 
Although this section contains no bytes, the
<B>sh_offset</B>

member contains the conceptual file offset.
<DT><B>SHT_REL</B>


<DD>
This section holds relocation offsets without explicit addends, such
as type
<B>Elf32_Rel</B>

for the 32-bit class of object files.
An object file may have multiple
relocation sections.
<DT><B>SHT_SHLIB</B>


<DD>
This section is reserved but has unspecified semantics.
<DT><B>SHT_DYNSYM</B>


<DD>
This section holds a minimal set of dynamic linking symbols.
An
object file can also contain a
<B>SHN_SYMTAB</B>

section.
<DT><B>SHT_LOPROC</B>


<DD>
This value up to and including
<B>SHT_HIPROC</B>

is reserved for processor-specific semantics.
<DT><B>SHT_HIPROC</B>


<DD>
This value down to and including
<B>SHT_LOPROC</B>

is reserved for processor-specific semantics.
<DT><B>SHT_LOUSER</B>


<DD>
This value specifies the lower bound of the range of indices reserved for
application programs.
<DT><B>SHT_HIUSER</B>


<DD>
This value specifies the upper bound of the range of indices reserved for
application programs.
Section types between
<B>SHT_LOUSER</B>

and
<B>SHT_HIUSER</B>

may be used by the application, without conflicting with current or future
system-defined section types.
</DL>
<P>

<P>

<DT><B>sh_flags</B>


<DD>
Sections support one-bit flags that describe miscellaneous attributes.
If a flag bit is set in
<B>sh_flags</B>

 
the attribute is
``on''

for the section.
Otherwise, the attribute is
``off''

or does not apply.
Undefined attributes are set to zero.
<P>

<DL COMPACT>
<P>

<DT><B>SHF_WRITE</B>


<DD>
This section contains data that should be writable during process
execution.
<DT><B>SHF_ALLOC</B>


<DD>
This section occupies memory during process execution.
Some control
sections do not reside in the memory image of an object file.
This
attribute is off for those sections.
<DT><B>SHF_EXECINSTR</B>


<DD>
This section contains executable machine instructions.
<DT><B>SHF_MASKPROC</B>


<DD>
All bits included in this mask are reserved for processor-specific
semantics.
</DL>
<P>

<P>

<DT><B>sh_addr</B>


<DD>
If this section appears in the memory image of a process, this member
holds the address at which the section's first byte should reside.
Otherwise, the member contains zero.
<DT><B>sh_offset</B>


<DD>
This member's value holds the byte offset from the beginning of the file
to the first byte in the section.
One section type,
<B>SHT_NOBITS</B>

 
occupies no space in the file, and its
<B>sh_offset</B>

member locates the conceptual placement in the file.
<DT><B>sh_size</B>


<DD>
This member holds the section's size in bytes.
Unless the section type
is
<B>SHT_NOBITS</B>

 
the section occupies
<B>sh_size</B>

bytes in the file.
A section of type
<B>SHT_NOBITS</B>

may have a non-zero size, but it occupies no space in the file.
<DT><B>sh_link</B>


<DD>
This member holds a section header table index link, whose interpretation
depends on the section type.
<DT><B>sh_info</B>


<DD>
This member holds extra information, whose interpretation depends on the
section type.
<DT><B>sh_addralign</B>


<DD>
Some sections have address alignment constraints.
If a section holds a
doubleword, the system must ensure doubleword alignment for the entire
section.
That is, the value of
<B>sh_addr</B>

must be congruent to zero, modulo the value of
<B>sh_addralign</B>

 
Only zero and positive integral powers of two are allowed.
Values of zero
or one mean the section has no alignment constraints.
<DT><B>sh_entsize</B>


<DD>
Some sections hold a table of fixed-sized entries, such as a symbol table.
For such a section, this member gives the size in bytes for each entry.
This member contains zero if the section does not hold a table of
fixed-size entries.
</DL>
<P>

<P>

Various sections hold program and control information:
<DL COMPACT>
<P>

<DT><B>.bss</B>
<DD>
This section holds uninitialized data that contributes to the program's
memory image.
By definition, the system initializes the data with zeros
when the program begins to run.
This section is of type
<B>SHT_NOBITS</B>

 
The attribute types are
<B>SHF_ALLOC</B>

and
<B>SHF_WRITE</B>

 
<DT><B>.comment</B>
<DD>
This section holds version control information.
This section is of type
<B>SHT_PROGBITS</B>

 
No attribute types are used.
<DT><B>.ctors</B>
<DD>
This section holds initialized pointers to the C++ constructor functions.
This section is of type
<B>SHT_PROGBITS</B>

 
The attribute types are
<B>SHF_ALLOC</B>

and
<B>SHF_WRITE</B>

 
<DT><B>.data</B>
<DD>
This section holds initialized data that contribute to the program's
memory image.
This section is of type
<B>SHT_PROGBITS</B>

 
The attribute types are
<B>SHF_ALLOC</B>

and
<B>SHF_WRITE</B>

 
<DT><B>.data1</B>
<DD>
This section holds initialized data that contribute to the program's
memory image.
This section is of type
<B>SHT_PROGBITS</B>

 
The attribute types are
<B>SHF_ALLOC</B>

and
<B>SHF_WRITE</B>

 
<DT><B>.debug</B>
<DD>
This section holds information for symbolic debugging.
The contents
are unspecified.
This section is of type
<B>SHT_PROGBITS</B>

 
No attribute types are used.
<DT><B>.dtors</B>
<DD>
This section holds initialized pointers to the C++ destructor functions.
This section is of type
<B>SHT_PROGBITS</B>

 
The attribute types are
<B>SHF_ALLOC</B>

and
<B>SHF_WRITE</B>

 
<DT><B>.dynamic</B>
<DD>
This section holds dynamic linking information.
The section's attributes
will include the
<B>SHF_ALLOC</B>

bit.
Whether the
<B>SHF_WRITE</B>

bit is set is processor-specific.
This section is of type
<B>SHT_DYNAMIC</B>

 
See the attributes above.
<DT><B>.dynstr</B>
<DD>
This section holds strings needed for dynamic linking, most commonly
the strings that represent the names associated with symbol table entries.
This section is of type
<B>SHT_STRTAB</B>

 
The attribute type used is
<B>SHF_ALLOC</B>

 
<DT><B>.dynsym</B>
<DD>
This section holds the dynamic linking symbol table.
This section is of type
<B>SHT_DYNSYM</B>

 
The attribute used is
<B>SHF_ALLOC</B>

 
<DT><B>.fini</B>
<DD>
This section holds executable instructions that contribute to the process
termination code.
When a program exits normally the system arranges to
execute the code in this section.
This section is of type
<B>SHT_PROGBITS</B>

 
The attributes used are
<B>SHF_ALLOC</B>

and
<B>SHF_EXECINSTR</B>

 
<DT><B>.got</B>
<DD>
This section holds the global offset table.
This section is of type
<B>SHT_PROGBITS</B>

 
The attributes are processor-specific.
<DT><B>.hash</B>
<DD>
This section holds a symbol hash table.
This section is of type
<B>SHT_HASH</B>

 
The attribute used is
<B>SHF_ALLOC</B>

 
<DT><B>.init</B>
<DD>
This section holds executable instructions that contribute to the process
initialization code.
When a program starts to run the system arranges to
execute the code in this section before calling the main program entry point.
This section is of type
<B>SHT_PROGBITS</B>

 
The attributes used are
<B>SHF_ALLOC</B>

and
<B>SHF_EXECINSTR</B>

 
<DT><B>.interp</B>
<DD>
This section holds the pathname of a program interpreter.
If the file has
a loadable segment that includes the section, the section's attributes will
include the
<B>SHF_ALLOC</B>

bit.
Otherwise, that bit will be off.
This section is of type
<B>SHT_PROGBITS</B>

 
<DT><B>.line</B>
<DD>
This section holds line number information for symbolic debugging, which
describes the correspondence between the program source and the machine code.
The contents are unspecified.
This section is of type
<B>SHT_PROGBITS</B>

 
No attribute types are used.
<DT><B>.note</B>
<DD>
This section holds information in the
``Note Section''

format described below.
This section is of type
<B>SHT_NOTE</B>

 
No attribute types are used.
Ox native executables usually contain a

<B>.note.openbsd.ident</B>

section to identify themselves, for the kernel to bypass any compatibility
ELF binary emulation tests when loading the file.
<DT><B>.plt</B>
<DD>
This section holds the procedure linkage table.
This section is of type
<B>SHT_PROGBITS</B>

 
The attributes are processor-specific.
<DT><B>.relNAME</B>
<DD>
This section holds relocation information as described below.
If the file
has a loadable segment that includes relocation, the section's attributes
will include the
<B>SHF_ALLOC</B>

bit.
Otherwise the bit will be off.
By convention,
``NAME''

is supplied by the section to which the relocations apply.
Thus a relocation
section for
<B>.text</B>

normally would have the name
<B>.rel.text</B>

 
This section is of type
<B>SHT_REL</B>

 
<DT><B>.relaNAME</B>
<DD>
This section holds relocation information as described below.
If the file
has a loadable segment that includes relocation, the section's attributes
will include the
<B>SHF_ALLOC</B>

bit.
Otherwise the bit will be off.
By convention,
``NAME''

is supplied by the section to which the relocations apply.
Thus a relocation
section for
<B>.text</B>

normally would have the name
<B>.rela.text</B>

 
This section is of type
<B>SHT_RELA</B>

 
<DT><B>.rodata</B>
<DD>
This section holds read-only data that typically contributes to a
non-writable segment in the process image.
This section is of type
<B>SHT_PROGBITS</B>

 
The attribute used is
<B>SHF_ALLOC</B>

 
<DT><B>.rodata1</B>
<DD>
This section holds read-only data that typically contributes to a
non-writable segment in the process image.
This section is of type
<B>SHT_PROGBITS</B>

 
The attribute used is
<B>SHF_ALLOC</B>

 
<DT><B>.shstrtab</B>
<DD>
This section holds section names.
This section is of type
<B>SHT_STRTAB</B>

 
No attribute types are used.
<DT><B>.strtab</B>
<DD>
This section holds strings, most commonly the strings that represent the
names associated with symbol table entries.
If the file has a loadable
segment that includes the symbol string table, the section's attributes
will include the
<B>SHF_ALLOC</B>

bit.
Otherwise the bit will be off.
This section is of type
<B>SHT_STRTAB</B>

 
<DT><B>.symtab</B>
<DD>
This section holds a symbol table.
If the file has a loadable segment
that includes the symbol table, the section's attributes will include
the
<B>SHF_ALLOC</B>

bit.
Otherwise the bit will be off.
This section is of type
<B>SHT_SYMTAB</B>

 
<DT><B>.text</B>
<DD>
This section holds the
``text''

 
or executable instructions, of a program.
This section is of type
<B>SHT_PROGBITS</B>

 
The attributes used are
<B>SHF_ALLOC</B>

and
<B>SHF_EXECINSTR</B>

 
</DL>
<P>

<P>

String table sections hold null-terminated character sequences, commonly
called strings.
The object file uses these strings to represent symbol
and section names.
One references a string as an index into the string
table section.
The first byte, which is index zero, is defined to hold
a null character.
Similarly, a string table's last byte is defined to
hold a null character, ensuring null termination for all strings.
<P>

An object file's symbol table holds information needed to locate and
relocate a program's symbolic definitions and references.
A symbol table
index is a subscript into this array.

<BLOCKQUOTE>
<PRE>
typedef struct {
        uint32_t        st_name;
        Elf32_Addr      st_value;
        uint32_t        st_size;
        unsigned char   st_info;
        unsigned char   st_other;
        uint16_t        st_shndx;
} Elf32_Sym;
</PRE>
</BLOCKQUOTE>


<BLOCKQUOTE>
<PRE>
typedef struct {
        uint32_t        st_name;
        unsigned char   st_info;
        unsigned char   st_other;
        uint16_t        st_shndx;
        Elf64_Addr      st_value;
        uint64_t        st_size;
} Elf64_Sym;
</PRE>
</BLOCKQUOTE>

<DL COMPACT>
<P>

<DT><B>st_name</B>


<DD>
This member holds an index into the object file's symbol string table,
which holds character representations of the symbol names.
If the value
is non-zero, it represents a string table index that gives the symbol
name.
Otherwise, the symbol table has no name.
<DT><B>st_value</B>


<DD>
This member gives the value of the associated symbol.
<DT><B>st_size</B>


<DD>
Many symbols have associated sizes.
This member holds zero if the symbol
has no size or an unknown size.
<DT><B>st_info</B>


<DD>
This member specifies the symbol's type and binding attributes:
<DL COMPACT>
<P>

<DT><B>STT_NOTYPE</B>


<DD>
The symbol's type is not defined.
<DT><B>STT_OBJECT</B>


<DD>
The symbol is associated with a data object.
<DT><B>STT_FUNC</B>


<DD>
The symbol is associated with a function or other executable code.
<DT><B>STT_SECTION</B>


<DD>
The symbol is associated with a section.
Symbol table entries of
this type exist primarily for relocation and normally have
<B>STB_LOCAL</B>

bindings.
<DT><B>STT_FILE</B>


<DD>
By convention, the symbol's name gives the name of the source file
associated with the object file.
A file symbol has
<B>STB_LOCAL</B>

bindings, its section index is
<B>SHN_ABS</B>

 
and it precedes the other
<B>STB_LOCAL</B>

symbols of the file, if it is present.
<DT><B>STT_LOPROC</B>


<DD>
This value up to and including
<B>STT_HIPROC</B>

is reserved for processor-specific semantics.
<DT><B>STT_HIPROC</B>


<DD>
This value down to and including
<B>STT_LOPROC</B>

is reserved for processor-specific semantics.
</DL>
<P>

<DL COMPACT>
<P>

<DT><B>STB_LOCAL</B>


<DD>
Local symbols are not visible outside the object file containing their
definition.
Local symbols of the same name may exist in multiple files
without interfering with each other.
<DT><B>STB_GLOBAL</B>


<DD>
Global symbols are visible to all object files being combined.
One file's
definition of a global symbol will satisfy another file's undefined
reference to the same symbol.
<DT><B>STB_WEAK</B>


<DD>
Weak symbols resemble global symbols, but their definitions have lower
precedence.
<DT><B>STB_LOPROC</B>


<DD>
This value up to and including
<B>STB_HIPROC</B>

is reserved for processor-specific semantics.
<DT><B>STB_HIPROC</B>


<DD>
This value down to and including
<B>STB_LOPROC</B>

is reserved for processor-specific semantics.
<P>

There are macros for packing and unpacking the binding and type fields:
<P>

<DL COMPACT>
<P>

<DT><B>
</B>

Fn ELF32_ST_BIND info

<DD>

<DD>or
Fn ELF64_ST_BIND info

extract a binding from an st_info value.
<DT><B>
</B>

Fn ELF64_ST_TYPE info

<DD>

<DD>or
Fn ELF32_ST_TYPE info

extract a type from an st_info value.
<DT><B>
</B>

Fn ELF32_ST_INFO bind type

<DD>

<DD>or
Fn ELF64_ST_INFO bind type

convert a binding and a type into an st_info value.
</DL>
<P>

</DL>
<P>

<P>

<DT><B>st_other</B>


<DD>
This member currently holds zero and has no defined meaning.
<DT><B>st_shndx</B>


<DD>
Every symbol table entry is
``defined''

in relation to some section.
This member holds the relevant section
header table index.
</DL>
<P>

<P>

Relocation is the process of connecting symbolic references with
symbolic definitions.
Relocatable files must have information that
describes how to modify their section contents, thus allowing executable
and shared object files to hold the right information for a process'
program image.
Relocation entries are these data.
<P>

Relocation structures that do not need an addend:

<BLOCKQUOTE>
<PRE>
typedef struct {
        Elf32_Addr     r_offset;
        uint32_t       r_info;
} Elf32_Rel;
</PRE>
</BLOCKQUOTE>


<BLOCKQUOTE>
<PRE>
typedef struct {
        Elf64_Addr     r_offset;
        uint64_t       r_info;
} Elf64_Rel;
</PRE>
</BLOCKQUOTE>

<P>

Relocation structures that need an addend:

<BLOCKQUOTE>
<PRE>
typedef struct {
        Elf32_Addr      r_offset;
        uint32_t        r_info;
        int32_t         r_addend;
} Elf32_Rela;
</PRE>
</BLOCKQUOTE>


<BLOCKQUOTE>
<PRE>
typedef struct {
        Elf64_Addr      r_offset;
        uint64_t        r_info;
        int64_t         r_addend;
} Elf64_Rela;
</PRE>
</BLOCKQUOTE>

<DL COMPACT>
<P>

<DT><B>r_offset</B>


<DD>
This member gives the location at which to apply the relocation action.
For a relocatable file, the value is the byte offset from the beginning
of the section to the storage unit affected by the relocation.
For an
executable file or shared object, the value is the virtual address of
the storage unit affected by the relocation.
<DT><B>r_info</B>


<DD>
This member gives both the symbol table index with respect to which the
relocation must be made and the type of relocation to apply.
Relocation
types are processor-specific.
When the text refers to a relocation
entry's relocation type or symbol table index, it means the result of
applying
<B>ELF_[32|64]_R_TYPE</B>

or
<B>ELF[32|64]_R_SYM</B>

 
respectively, to the entry's
<B>r_info</B>

member.
<DT><B>r_addend</B>


<DD>
This member specifies a constant addend used to compute the value to be
stored into the relocatable field.
</DL>
<P>

<A NAME="lbAE">&nbsp;</A>
<H2>SEE ALSO</H2>

<A HREF="../man1/as.1.html">as</A>(1),


<A HREF="../man1/gdb.1.html">gdb</A>(1),


<A HREF="../man1/ld.1.html">ld</A>(1),


<A HREF="../man1/objdump.1.html">objdump</A>(1),


<A HREF="../man2/execve.2.html">execve</A>(2),


<A HREF="../man5/core.5.html">core</A>(5)


<DL COMPACT><DT><DD>
Hewlett-Packard
<I>Elf-64 Object File Format</I>
</DL>

<DL COMPACT><DT><DD>
Santa Cruz Operation
<I>System V Application Binary Interface</I>
</DL>

<DL COMPACT><DT><DD>
Unix System Laboratories
<I>Object Files</I>
<I>&quot;Executable and Linking Format (ELF)&quot;</I>
</DL>

<A NAME="lbAF">&nbsp;</A>
<H2>HISTORY</H2>

Ox ELF support first appeared in

Ox 1.2 ,

although not all supported platforms use it as the native
binary file format.
ELF in itself first appeared in
AT&amp;T System
V .
The ELF format is an adopted standard.
<A NAME="lbAG">&nbsp;</A>
<H2>AUTHORS</H2>

The original version of this manual page was written by
An Jeroen Ruigrok van der Werven

Aq <A HREF="mailto:asmodai@FreeBSD.org">asmodai@FreeBSD.org</A>

with inspiration from BSDi's
Bs x

<B>elf</B>

manpage.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">SEE ALSO</A><DD>
<DT><A HREF="#lbAF">HISTORY</A><DD>
<DT><A HREF="#lbAG">AUTHORS</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 02:11:22 GMT, April 20, 2020
</BODY>
</HTML>
