<!--
Copyright (c) 2002 by Michael Kerrisk &lt;mtk-manpages@gmx.net&gt;
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of CAPABILITIES</TITLE>
</HEAD><BODY>
<H1>CAPABILITIES</H1>
Section: Linux Programmer's Manual (7)<BR>Updated: 2005-10-28<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

capabilities - overview of Linux capabilities
<A NAME="lbAC">&nbsp;</A>
<H2>DESCRIPTION</H2>

For the purpose of performing permission checks,
traditional Unix implementations distinguish two categories of processes:
<I>privileged</I>

processes (whose effective user ID is 0, referred to as superuser or root),
and
<I>unprivileged</I>

processes (whose effective UID is non-zero).
Privileged processes bypass all kernel permission checks,
while unprivileged processes are subject to full permission
checking based on the process's credentials
(usually: effective UID, effective GID, and supplementary group list).
<P>
Starting with kernel 2.2, Linux divides the privileges traditionally 
associated with superuser into distinct units, known as 
<I>capabilities</I>,

which can be independently enabled and disabled.
Capabilities are a per-thread attribute.
<A NAME="lbAD">&nbsp;</A>
<H3>Capabilities List</H3>

<P>
As at Linux 2.6.14, the following capabilities are implemented:
<DL COMPACT>
<DT><B>CAP_AUDIT_CONTROL</B> (since Linux 2.6.11)

<DD>
Enable and disable kernel auditing; change auditing filter rules;
retrieve auditing status and filtering rules.
<DT><B>CAP_AUDIT_WRITE</B> (since Linux 2.6.11)

<DD>
Allow records to be written to kernel auditing log.
<DT><B>CAP_CHOWN</B>

<DD>
Allow arbitrary changes to file UIDs and GIDs (see
<B><A HREF="../man2/chown.2.html">chown</A></B>(2)).

<DT><B>CAP_DAC_OVERRIDE</B>

<DD>
Bypass file read, write, and execute permission checks.
(DAC = &quot;discretionary access control&quot;.)
<DT><B>CAP_DAC_READ_SEARCH</B>

<DD>
Bypass file read permission checks and
directory read and execute permission checks.
<DT><B>CAP_FOWNER</B>

<DD>
Bypass permission checks on operations that normally
require the file system UID of the process to match the UID of
the file (e.g.,
<B><A HREF="../man2/chmod.2.html">chmod</A></B>(2),

<B><A HREF="../man2/utime.2.html">utime</A></B>(2)),

excluding those operations covered by the
<B>CAP_DAC_OVERRIDE</B>

and
<B>CAP_DAC_READ_SEARCH</B>;

set extended file attributes (see
<B><A HREF="../man1/chattr.1.html">chattr</A></B>(1))

on arbitrary files;
set Access Control Lists (ACLs) on arbitrary files;
ignore directory sticky bit on file deletion;
specify
<B>O_NOATIME</B>

for arbitrary files in
<B><A HREF="../man2/open.2.html">open</A></B>(2)

and
<B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2).

<DT><B>CAP_FSETID</B>

<DD>
Don't clear set-user-ID and set-group-ID bits when a file is modified;
permit setting of the set-group-ID bit for a file whose GID does not match
the file system or any of the supplementary GIDs of the calling process.
<DT><B>CAP_IPC_LOCK</B>

<DD>
Permit memory locking
(<B><A HREF="../man2/mlock.2.html">mlock</A></B>(2),

<B><A HREF="../man2/mlockall.2.html">mlockall</A></B>(2),

<B><A HREF="../man2/mmap.2.html">mmap</A></B>(2),

<B><A HREF="../man2/shmctl.2.html">shmctl</A></B>(2)).

<DT><B>CAP_IPC_OWNER</B>

<DD>
Bypass permission checks for operations on System V IPC objects.
<DT><B>CAP_KILL</B>

<DD>
Bypass permission checks for sending signals (see
<B><A HREF="../man2/kill.2.html">kill</A></B>(2)).

This includes use of the KDSIGACCEPT ioctl.



<DT><B>CAP_LEASE</B>

<DD>
(Linux 2.4 onwards)  Allow file leases to be established on
arbitrary files (see
<B><A HREF="../man2/fcntl.2.html">fcntl</A></B>(2)).

<DT><B>CAP_LINUX_IMMUTABLE</B>

<DD>
Allow setting of the
<B>EXT2_APPEND_FL</B>

and
<B>EXT2_IMMUTABLE_FL</B>


extended file attributes (see
<B><A HREF="../man1/chattr.1.html">chattr</A></B>(1)).

<DT><B>CAP_MKNOD</B>

<DD>
(Linux 2.4 onwards)
Allow creation of special files using
<B><A HREF="../man2/mknod.2.html">mknod</A></B>(2).

<DT><B>CAP_NET_ADMIN</B>

<DD>
Allow various network-related operations
(e.g., setting privileged socket options,
enabling multicasting, interface configuration,
modifying routing tables).
<DT><B>CAP_NET_BIND_SERVICE</B>

<DD>
Allow binding to Internet domain reserved socket ports
(port numbers less than 1024).
<DT><B>CAP_NET_BROADCAST</B>

<DD>
(Unused)  Allow socket broadcasting, and listening multicasts.
<DT><B>CAP_NET_RAW</B>

<DD>
Permit use of RAW and PACKET sockets.

<DT><B>CAP_SETGID</B>

<DD>
Allow arbitrary manipulations of process GIDs and supplementary GID list;
allow forged GID when passing socket credentials via Unix domain sockets.
<DT><B>CAP_SETPCAP</B>

<DD>
Grant or remove any capability in the caller's
permitted capability set to or from any other process.
<DT><B>CAP_SETUID</B>

<DD>
Allow arbitrary manipulations of process UIDs
(<B><A HREF="../man2/setuid.2.html">setuid</A></B>(2),

<B><A HREF="../man2/setreuid.2.html">setreuid</A></B>(2),

<B><A HREF="../man2/setresuid.2.html">setresuid</A></B>(2),

<B><A HREF="../man2/setfsuid.2.html">setfsuid</A></B>(2));

allow forged UID when passing socket credentials via Unix domain sockets.

<DT><B>CAP_SYS_ADMIN</B>

<DD>
Permit a range of system administration operations including:
<B><A HREF="../man2/quotactl.2.html">quotactl</A></B>(2),

<B><A HREF="../man2/mount.2.html">mount</A></B>(2),

<B><A HREF="../man2/umount.2.html">umount</A></B>(2),

<B><A HREF="../man2/swapon.2.html">swapon</A></B>(2)<B>,</B>

<B><A HREF="../man2/swapoff.2.html">swapoff</A></B>(2)<B>,</B>

<B><A HREF="../man2/sethostname.2.html">sethostname</A></B>(2),

<B><A HREF="../man2/setdomainname.2.html">setdomainname</A></B>(2),

<B>IPC_SET</B>

and
<B>IPC_RMID</B>

operations on arbitrary System V IPC objects;
perform operations on
<I>trusted</I>

and
<I>security</I>

Extended Attributes (see
<B><A HREF="../man5/attr.5.html">attr</A></B>(5));

call
<B><A HREF="../man2/lookup_dcookie.2.html">lookup_dcookie</A></B>(2);

use
<B><A HREF="../man2/ioprio_set.2.html">ioprio_set</A></B>(2)

to assign
<B>IOPRIO_CLASS_RT</B>

and
IOPRIO_CLASS_IDLE
I/O scheduling classes;
perform 
<B><A HREF="../man2/keyctl.2.html">keyctl</A></B>(2)

<B>KEYCTL_CHOWN</B>

and
<B>KEYCTL_SETPERM </B>

operations.
allow forged UID when passing socket credentials;
exceed
<I>/proc/sys/fs/file-max</I>,

the system-wide limit on the number of open files,
in system calls that open files (e.g.,
<B><A HREF="../man2/accept.2.html">accept</A></B>(2),

<B><A HREF="../man2/execve.2.html">execve</A></B>(2),

<B><A HREF="../man2/open.2.html">open</A></B>(2),

<B><A HREF="../man2/pipe.2.html">pipe</A></B>(2);

without this capability these system calls will fail with the error 
<B>ENFILE </B>

if this limit is encountered).
<DT><B>CAP_SYS_BOOT</B>

<DD>
Permit calls to
<B><A HREF="../man2/reboot.2.html">reboot</A></B>(2)

and
<B><A HREF="../man2/kexec_load.2.html">kexec_load</A></B>(2).

<DT><B>CAP_SYS_CHROOT</B>

<DD>
Permit calls to
<B><A HREF="../man2/chroot.2.html">chroot</A></B>(2).

<DT><B>CAP_SYS_MODULE</B>

<DD>
Allow loading and unloading of kernel modules;
allow modifications to capability bounding set (see
<B><A HREF="../man2/init_module.2.html">init_module</A></B>(2)

and
<B><A HREF="../man2/delete_module.2.html">delete_module</A></B>(2)).

<DT><B>CAP_SYS_NICE</B>

<DD>
Allow raising process nice value
(<B><A HREF="../man2/nice.2.html">nice</A></B>(2),

<B><A HREF="../man2/setpriority.2.html">setpriority</A></B>(2))

and changing of the nice value for arbitrary processes;
allow setting of real-time scheduling policies for calling process,
and setting scheduling policies and priorities for arbitrary processes
(<B><A HREF="../man2/sched_setscheduler.2.html">sched_setscheduler</A></B>(2),

<B><A HREF="../man2/sched_setparam.2.html">sched_setparam</A></B>(2));

set CPU affinity for arbitrary processes
(<B><A HREF="../man2/sched_setaffinity.2.html">sched_setaffinity</A></B>(2));

set I/O scheduling class and priority for arbitrary processes
(<B><A HREF="../man2/ioprio_set.2.html">ioprio_set</A></B>(2));

allow
<B><A HREF="../man2/migrate_pages.2.html">migrate_pages</A></B>(2)

to be applied to arbitrary processes and allow processes
to be migrated to arbitrary nodes;




use the
<B>MPOL_MF_MOVE_ALL</B>

flag with 
<B><A HREF="../man2/mbind.2.html">mbind</A></B>(2).

<DT><B>CAP_SYS_PACCT</B>

<DD>
Permit calls to
<B><A HREF="../man2/acct.2.html">acct</A></B>(2).

<DT><B>CAP_SYS_PTRACE</B>

<DD>
Allow arbitrary processes to be traced using
<B><A HREF="../man2/ptrace.2.html">ptrace</A></B>(2)

<DT><B>CAP_SYS_RAWIO</B>

<DD>
Permit I/O port operations
(<B><A HREF="../man2/iopl.2.html">iopl</A></B>(2)

and
<B><A HREF="../man2/ioperm.2.html">ioperm</A></B>(2));

access

<DT><B>CAP_SYS_RESOURCE</B>

<DD>
Permit: use of reserved space on ext2 file systems;
<B><A HREF="../man2/ioctl.2.html">ioctl</A></B>(2)

calls controlling ext3 journaling;
disk quota limits to be overridden;
resource limits to be increased (see
<B><A HREF="../man2/setrlimit.2.html">setrlimit</A></B>(2));

<B>RLIMIT_NPROC</B>

resource limit to be overridden;
<I>msg_qbytes</I>

limit for a message queue to be
raised above the limit in
<I>/proc/sys/kernel/msgmnb</I>

(see
<B><A HREF="../man2/msgop.2.html">msgop</A></B>(2)

and
<B><A HREF="../man2/msgctl.2.html">msgctl</A></B>(2).

<DT><B>CAP_SYS_TIME</B>

<DD>
Allow modification of system clock
(<B><A HREF="../man2/settimeofday.2.html">settimeofday</A></B>(2),

<B><A HREF="../man2/stime.2.html">stime</A></B>(2),

<B><A HREF="../man2/adjtimex.2.html">adjtimex</A></B>(2));

allow modification of real-time (hardware) clock
<DT><B>CAP_SYS_TTY_CONFIG</B>

<DD>
Permit calls to
<B><A HREF="../man2/vhangup.2.html">vhangup</A></B>(2).

</DL>
<A NAME="lbAE">&nbsp;</A>
<H3>Capability Sets</H3>

Each thread has three capability sets containing zero or more
of the above capabilities:
<DL COMPACT>
<DT><I>Effective</I>:

<DD>
the capabilities used by the kernel to
perform permission checks for the thread.
<DT><I>Permitted</I>:

<DD>
the capabilities that the thread may assume
(i.e., a limiting superset for the effective and inheritable sets).
If a thread drops a capability from its permitted set,
it can never re-acquire that capability (unless it 
<B>exec</B>()s

a set-user-ID-root program).
<DT><I>inheritable</I>:

<DD>
the capabilities preserved across an
<B><A HREF="../man2/execve.2.html">execve</A></B>(2).

</DL>
<P>

A child created via
<B><A HREF="../man2/fork.2.html">fork</A></B>(2)

inherits copies of its parent's capability sets.
See below for a discussion of the treatment of capabilities during
<B>exec</B>().

<P>

Using
<B><A HREF="../man2/capset.2.html">capset</A></B>(2),

a thread may manipulate its own capability sets, or, if it has the
<B>CAP_SETPCAP</B>

capability, those of a thread in another process.
<A NAME="lbAF">&nbsp;</A>
<H3>Capability bounding set</H3>

When a program is execed, the permitted and effective capabilities
are ANDed with the current value of the so-called
<I>capability bounding set</I>,

defined in the file
<I>/proc/sys/kernel/cap-bound</I>.

This parameter can be used to place a system-wide limit on the
capabilities granted to all subsequently executed programs.
(Confusingly, this bit mask parameter is expressed as a
signed decimal number in
<I>/proc/sys/kernel/cap-bound</I>.)

<P>
Only the
<B>init</B>

process may set bits in the capability bounding set;
other than that, the superuser may only clear bits in this set.
<P>
On a standard system the capability bounding set always masks out the
<B>CAP_SETPCAP</B>

capability.
To remove this restriction (dangerous!), modify the definition of
<B>CAP_INIT_EFF_SET</B>

in
<I>include/linux/capability.h</I>

and rebuild the kernel.
<P>
The capability bounding set feature was added to Linux starting with
kernel version 2.2.11.
<A NAME="lbAG">&nbsp;</A>
<H3>Current and Future Implementation</H3>

A full implementation of capabilities requires:
<DL COMPACT>
<DT>1.<DD>
that for all privileged operations,
the kernel check whether the thread has the required
capability in its effective set.
<DT>2.<DD>
that the kernel provide 
system calls allowing a thread's capability sets to
be changed and retrieved.
<DT>3.<DD>
file system support for attaching capabilities to an executable file,
so that a process gains those capabilities when the file is execed.
</DL>
<P>

As at Linux 2.6.14, only the first two of these requirements are met.
<P>
Eventually, it should be possible to associate three 
capability sets with an executable file, which,
in conjunction with the capability sets of the thread,
will determine the capabilities of a thread after an
<B>exec</B>():

<DL COMPACT>
<DT><I>Inheritable</I> (formerly known as <I>allowed</I>):

<DD>
this set is ANDed with the thread's inheritable set to determine which
inheritable capabilities are permitted to the thread after the 
<B>exec</B>().

<DT><I>Permitted</I> (formerly known as <I>forced</I>):

<DD>
the capabilities automatically permitted to the thread,
regardless of the thread's inheritable capabilities.
<DT><I>Effective</I>:

<DD>
those capabilities in the thread's new permitted set are
also to be set in the new effective set.
(F(effective) would normally be either all zeroes or all ones.)
</DL>
<P>

In the meantime, since the current implementation does not
support file capability sets, during an 
<B>exec</B>():

<DL COMPACT>
<DT>1.<DD>
All three file capability sets are initially assumed to be cleared.
<DT>2.<DD>
If a set-user-ID-root program is being execed,
or the real user ID of the process is 0 (root)
then the file inheritable and permitted sets are defined to be all ones
(i.e., all capabilities enabled).
<DT>3.<DD>
If a set-user-ID-root program is being executed,
then the file effective set is defined to be all ones.
</DL>
<A NAME="lbAH">&nbsp;</A>
<H3>Transformation of Capabilities During exec()</H3>

<P>

During an 
<B>exec</B>(),

the kernel calculates the new capabilities of
the process using the following algorithm:

<PRE>

P'(permitted) = (P(inheritable) &amp; F(inheritable)) | 
                (F(permitted) &amp; cap_bset)

P'(effective) = P'(permitted) &amp; F(effective)

P'(inheritable) = P(inheritable)    [i.e., unchanged]

</PRE>


where:
<DL COMPACT>
<DT>P<DD>
denotes the value of a thread capability set before the 
<B>exec</B>()

<DT>P'<DD>
denotes the value of a capability set after the 
<B>exec</B>()

<DT>F<DD>
denotes a file capability set
<DT>cap_bset<DD>
is the value of the capability bounding set.
</DL>
<P>

In the current implementation, the upshot of this algorithm is that
when a process 
<B>exec</B>()s

a set-user-ID-root program, or when a process with an effective UID of 0
<B>exec</B>()s

a program,
it gains all capabilities in its permitted and effective capability sets, 
except those masked out by the capability bounding set (i.e., 
<B>CAP_SETPCAP</B>).




This provides semantics that are the same as those provided by
traditional Unix systems.
<A NAME="lbAI">&nbsp;</A>
<H3>Effect of User ID Changes on Capabilities</H3>

To preserve the traditional semantics for transitions between 
0 and non-zero user IDs, 
the kernel makes the following changes to a thread's capability 
sets on changes to the thread's real, effective, saved set, 
and file system user IDs (using
<B><A HREF="../man2/setuid.2.html">setuid</A></B>(2),

<B><A HREF="../man2/setresuid.2.html">setresuid</A></B>(2),

or similar):
<DL COMPACT>
<DT>1.<DD>
If one or more of the real, effective or saved set user IDs 
was previously 0, and as a result of the UID changes all of these IDs 
have a non-zero value, 
then all capabilities are cleared from the permitted and effective 
capability sets.
<DT>2.<DD>
If the effective user ID is changed from 0 to non-zero, 
then all capabilities are cleared from the effective set.
<DT>3.<DD>
If the effective user ID is changed from non-zero to 0,
then the permitted set is copied to the effective set. 
<DT>4.<DD>
If the file system user ID is changed from 0 to non-zero (see
<B><A HREF="../man2/setfsuid.2.html">setfsuid</A></B>(2))

then the following capabilities are cleared from the effective set:
<B>CAP_CHOWN</B>,

<B>CAP_DAC_OVERRIDE</B>,

<B>CAP_DAC_READ_SEARCH</B>,

<B>CAP_FOWNER</B>,

and
<B>CAP_FSETID</B>.

If the file system UID is changed from non-zero to 0,
then any of these capabilities that are enabled in the permitted set 
are enabled in the effective set.
</DL>
<P>

If a thread that has a 0 value for one or more of its user IDs wants
to prevent its permitted capability set being cleared when it resets
all of its user IDs to non-zero values, it can do so using the
<B>prctl</B>()

<B>PR_SET_KEEPCAPS</B>

operation.
<A NAME="lbAJ">&nbsp;</A>
<H2>NOTES</H2>

The
<I>libcap</I>

package provides a suite of routines for setting and
getting capabilities that is more comfortable and less likely
to change than the interface provided by
<B><A HREF="../man2/capset.2.html">capset</A></B>(2)

and
<B><A HREF="../man2/capget.2.html">capget</A></B>(2).

<A NAME="lbAK">&nbsp;</A>
<H2>CONFORMING TO</H2>

No standards govern capabilities, but the Linux capability implementation
is based on the withdrawn POSIX 1003.1e draft standard.
<A NAME="lbAL">&nbsp;</A>
<H2>BUGS</H2>

There is as yet no file system support allowing capabilities to be
associated with executable files.
<A NAME="lbAM">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="../man2/capget.2.html">capget</A></B>(2),

<B><A HREF="../man2/prctl.2.html">prctl</A></B>(2),

<B><A HREF="../man2/setfsuid.2.html">setfsuid</A></B>(2),

<B><A HREF="../man7/pthreads.7.html">pthreads</A></B>(7)

<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">DESCRIPTION</A><DD>
<DL>
<DT><A HREF="#lbAD">Capabilities List</A><DD>
<DT><A HREF="#lbAE">Capability Sets</A><DD>
<DT><A HREF="#lbAF">Capability bounding set</A><DD>
<DT><A HREF="#lbAG">Current and Future Implementation</A><DD>
<DT><A HREF="#lbAH">Transformation of Capabilities During exec()</A><DD>
<DT><A HREF="#lbAI">Effect of User ID Changes on Capabilities</A><DD>
</DL>
<DT><A HREF="#lbAJ">NOTES</A><DD>
<DT><A HREF="#lbAK">CONFORMING TO</A><DD>
<DT><A HREF="#lbAL">BUGS</A><DD>
<DT><A HREF="#lbAM">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 02:27:27 GMT, April 20, 2020
</BODY>
</HTML>
