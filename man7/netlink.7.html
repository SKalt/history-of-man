<!--
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of NETLINK</TITLE>
</HEAD><BODY>
<H1>NETLINK</H1>
Section: Linux Programmer's Manual (7)<BR>Updated: 1999-04-27<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

netlink, PF_NETLINK - Communication between kernel and user
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<PRE>
<B>#include &lt;<A HREF="file:///usr/include/asm/types.h">asm/types.h</A>&gt;</B>
<BR>
<B>#include &lt;<A HREF="file:///usr/include/sys/socket.h">sys/socket.h</A>&gt;</B>
<BR>
<B>#include &lt;<A HREF="file:///usr/include/linux/netlink.h">linux/netlink.h</A>&gt; </B>
<BR>

<B>netlink_socket = socket(PF_NETLINK, </B><I>socket_type</I><B>, </B><I>netlink_family</I><B>);</B>
</PRE><A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

Netlink is used to transfer information between kernel modules and user space processes.  
It consists of a standard sockets based interface for user processes and an
internal kernel API for kernel modules. The internal kernel interface is not 
documented in this man page. Also there is an obsolete netlink interface via
netlink character devices, this interface is not documented here and is only
provided for backwards compatibility. 
<P>
Netlink is a datagram oriented service.  Both
<B>SOCK_RAW </B>

and
<B>SOCK_DGRAM</B>

are valid values for
<I>socket_type</I>;

however the netlink protocol does not distinguish between
datagram and raw sockets.
<P>
<I>netlink_family</I>

selects the kernel module or netlink group to communicate with. 
The currently assigned netlink families are:
<DL COMPACT>
<DT><B>NETLINK_ROUTE</B>

<DD>
Receives routing updates and may be used to modify the IPv4 routing
table (see
<B><A HREF="../man7/rtnetlink.7.html">rtnetlink</A></B>(7)).

<DT><B>NETLINK_FIREWALL </B>

<DD>
Receives packets sent by the IPv4 firewall code.
<DT><B>NETLINK_ARPD</B>

<DD>
For managing the arp table in user space.
<DT><B>NETLINK_ROUTE6</B>

<DD>
Receives and sends IPv6 routing table updates.
<DT><B>NETLINK_IP6_FW</B>

<DD>
to receive packets that failed the IPv6 firewall checks (currently not
implemented).
<DT><B>NETLINK_TAPBASE</B>...<B>NETLINK_TAPBASE+15</B>

<DD>
are the instances of the
<B>ethertap</B>

device. Ethertap is a pseudo network tunnel device that allows an
ethernet driver to be simulated from user space.
<DT><B>NETLINK_SKIP</B>

<DD>
Reserved for ENskip.
<DT><B>NETLINK_USERSOCK</B>

<DD>
is reserved for future user space protocols.
</DL>
<P>

Netlink messages consist of a byte stream with one or multiple 
<B>nlmsghdr</B>

headers and associated payload.
For multipart messages the first and all following headers have the
<B>NLM_F_MULTI</B>

flag set, except for the last header
which has the type
<B>NLMSG_DONE</B>.

The byte stream should only be accessed with the standard
<B>NLMSG_*</B>

macros, see
<B><A HREF="../man3/netlink.3.html">netlink</A></B>(3).

<P>
Netlink is not a reliable protocol.  It tries its best to deliver a 
message to its destination(s), but may drop messages when an out of
memory condition or other error occurs.  For reliable transfer the
sender can request an acknowledgement from the receiver by setting the
<B>NLM_F_ACK</B>

flag.  An acknowledgment is an
<B>NLMSG_ERROR </B>

packet with the error field set to 0.  The application must generate
acks for received messages itself.  The kernel tries to send an
<B>NLMSG_ERROR</B>

message for every failed packet.  A user process should follow this convention too. 
<P>
Each netlink family has a set of 32 multicast groups.
When
<B><A HREF="../man2/bind.2.html">bind</A></B>(2)

is called on the socket, the
<B>nl_groups</B>

field in the
<B>sockaddr_nl</B>

should be set to a bitmask of the groups which it wishes to listen to.
The default value for this field is zero which means that no multicasts
will be received.
A socket may multicast messages to any of the multicast groups by setting
<B>nl_groups</B>

to a bitmask of the groups it wishes to send to when it calls
<B><A HREF="../man2/sendmsg.2.html">sendmsg</A></B>(2)

or does a 
<B><A HREF="../man2/connect.2.html">connect</A></B>(2).

Only users with an effective UID of 0 or the
<B>CAP_NET_ADMIN</B>

capability may send or listen to
a netlink multicast group.
Any replies to a message received for a multicast group
should be sent back to the sending PID and the multicast group. 
<P>
<DL COMPACT><DT><DD>
<PRE>

struct nlmsghdr
{
    __u32    nlmsg_len;  /* Length of message including header */
    __u16    nlmsg_type; /* Message content */
    __u16    nlmsg_flags;/* Additional flags */
    __u32    nlmsg_seq;  /* Sequence number */
    __u32    nlmsg_pid;  /* PID of the process that opened the socket */
};


struct nlmsgerr
{
    int      error;      /* negative errno or 0 for acks. */ 
    struct nlmsghdr msg; /* message header that caused the error */ 
};

</PRE>

</DL>

<P>
After each
<B>nlmsghdr</B>

the payload follows. 
<B>nlmsg_type</B>

can be one of the standard message types: 
<B>NLMSG_NOOP</B>

message is to be ignored,
<B>NLMSG_ERROR</B>

the message signals an error and the payload contains a 
<I>nlmsgerr </I>

structure,
<B>NLMSG_DONE</B>

message terminates a multipart message,



<P>
A netlink family usually specifies more message types, see the
appropriate man pages for that, e.g. 
<B><A HREF="../man7/rtnetlink.7.html">rtnetlink</A></B>(7)

for 
<I>NETLINK_ROUTE</I>.

<P>
<TABLE>
<TR VALIGN=top><TD><B>Standard Flag bits in nlmsg_flags</B><BR></TD></TR>
<TR VALIGN=top><TD COLSPAN=2>NLM_F_REQUEST:set on all request messages<BR></TD></TR>
<TR VALIGN=top><TD>NLM_F_MULTI:T{<BR></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>the message is part of a multipart message terminated by <BR></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>NLMSG_DONE<BR></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>T}<BR></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>NLM_F_ACK:reply with an acknowledgment on success<BR></TD><TD><BR></TD></TR>
<TR VALIGN=top><TD>NLM_F_ECHO:echo this request<BR></TD><TD><BR></TD></TR>
</TABLE>

<P>
<TABLE>
<TR VALIGN=top><TD COLSPAN=2>Additional flag bits for GET requests<BR></TD></TR>
<TR VALIGN=top><TD>NLM_F_ROOT</TD><TD>Return the complete table instead of a single entry.<BR></TD></TR>
<TR VALIGN=top><TD>NLM_F_MATCH</TD><TD>Not implemented yet. <BR></TD></TR>
<TR VALIGN=top><TD>NLM_F_ATOMIC</TD><TD>Return an atomic snapshot of the table.<BR></TD></TR>
<TR VALIGN=top><TD>NLM_F_DUMP</TD><TD>not documented yet.<BR></TD></TR>
</TABLE>

<P>
<TABLE>
<TR VALIGN=top><TD COLSPAN=2>Additional flag bits for NEW requests<BR></TD></TR>
<TR VALIGN=top><TD>NLM_F_REPLACE</TD><TD>Override existing object.<BR></TD></TR>
<TR VALIGN=top><TD>NLM_F_EXCL</TD><TD>Don't replace if the object already exists.<BR></TD></TR>
<TR VALIGN=top><TD>NLM_F_CREATE</TD><TD>Create object if it doesn't already exist.<BR></TD></TR>
<TR VALIGN=top><TD>NLM_F_APPEND</TD><TD>Add to the end of the object list.<BR></TD></TR>
</TABLE>

<P>
Note that NLM_F_ATOMIC requires CAP_NET_ADMIN or superuser rights.
<P>
<A NAME="lbAE">&nbsp;</A>
<H2>ADDRESS FORMATS</H2>

The
<B>sockaddr_nl</B>

structure describes a netlink client in user space or in the kernel.
A sockaddr_nl can be either unicast (only send to one peer) or send 
to netlink groups (nl_groups not equal 0). 
<P>
<DL COMPACT><DT><DD>
<PRE>
struct sockaddr_nl
{
    sa_family_t nl_family;    /* AF_NETLINK */
    unsigned short nl_pad;    /* zero */
    pid_t       nl_pid;       /* process ID */
    __u32       nl_groups;    /* multicast groups mask */
};
</PRE>

</DL>

<P>
<B>nl_pid</B>

is the PID of the process owning the destination socket, or 0 if the
destination is in the kernel. 
<B>nl_groups </B>

is a bitmask with every bit representing a netlink group number.

<P>
<P>
<A NAME="lbAF">&nbsp;</A>
<H2>BUGS</H2>

This man page is not complete. 
<P>
<A NAME="lbAG">&nbsp;</A>
<H2>NOTES</H2>

It is often better to use netlink via 
<B>libnetlink</B>

than via the low level kernel interface.
<P>
<A NAME="lbAH">&nbsp;</A>
<H2>VERSIONS</H2>

The socket interface to netlink is a new feature of Linux 2.2
<P>
Linux 2.0 supported a more primitive device based netlink interface (which
is still available as a compatibility option). This obsolete interface is not
described here. 
<P>
<A NAME="lbAI">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="../man3/cmsg.3.html">cmsg</A></B>(3),

<B><A HREF="../man3/netlink.3.html">netlink</A></B>(3),

<B><A HREF="../man7/capabilities.7.html">capabilities</A></B>(7),

<B><A HREF="../man7/rtnetlink.7.html">rtnetlink</A></B>(7)

<P>

<A HREF="ftp://ftp.inr.ac.ru/ip-routing/iproute2*">ftp://ftp.inr.ac.ru/ip-routing/iproute2*</A> 
for libnetlink
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">ADDRESS FORMATS</A><DD>
<DT><A HREF="#lbAF">BUGS</A><DD>
<DT><A HREF="#lbAG">NOTES</A><DD>
<DT><A HREF="#lbAH">VERSIONS</A><DD>
<DT><A HREF="#lbAI">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 02:16:45 GMT, April 20, 2020
</BODY>
</HTML>
