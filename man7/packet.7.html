<!--
-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML><HEAD><TITLE>Man page of PACKET</TITLE>
</HEAD><BODY>
<H1>PACKET</H1>
Section: Linux Programmer's Manual (7)<BR>Updated: 1999-04-29<BR><A HREF="#index">Index</A>
<A HREF="../index.html">Return to Main Contents</A><HR>

<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

packet, PF_PACKET - packet interface on device level. 
<A NAME="lbAC">&nbsp;</A>
<H2>SYNOPSIS</H2>

<PRE>
<B>#include &lt;<A HREF="file:///usr/include/sys/socket.h">sys/socket.h</A>&gt;</B>
<BR>
<B>#include &lt;<A HREF="file:///usr/include/netpacket/packet.h">netpacket/packet.h</A>&gt;</B>
<BR>
<B>#include &lt;<A HREF="file:///usr/include/net/ethernet.h">net/ethernet.h</A>&gt;       /* the L2 protocols */</B>

<B>packet_socket = socket(PF_PACKET, int </B><I>socket_type</I><B>, int protocol</B><I>);</I>
</PRE>

<A NAME="lbAD">&nbsp;</A>
<H2>DESCRIPTION</H2>

Packet sockets are used to receive or send raw packets at the device driver<BR>
(OSI Layer 2)
level. They allow the user to implement protocol modules in user space 
on top of the physical layer.
<P>
The
<I>socket_type</I>

is either 
<B>SOCK_RAW </B>

for raw packets including the link level header or 
<B>SOCK_DGRAM</B>

for cooked packets with the link level header removed. The link level
header information is available in a common format in a 
<B>sockaddr_ll</B>.

<I>protocol </I>

is the IEEE 802.3 protocol number in network order. See the 
<B>&lt;<A HREF="file:///usr/include/linux/if_ether.h">linux/if_ether.h</A>&gt; </B>

include file for a list of allowed protocols. When protocol 
is set to
<B>htons(ETH_P_ALL) </B>

then all protocols are received.
All incoming packets of that protocol type will be passed to the packet
socket before they are passed to the protocols implemented in the kernel.
<BR>&nbsp;
Only processes with effective UID 0 or the
<B>CAP_NET_RAW</B>

capability may open packet sockets. 
<P>
<B>SOCK_RAW</B>

packets are passed to and from the device driver without any changes in
the packet data.  When receiving a packet, the address is still parsed and
passed in a standard
<B>sockaddr_ll</B>

address structure.  When transmitting a packet, the user supplied buffer
should contain the physical layer header.  That packet is then
queued unmodified to the network driver of the interface defined by the
destination address. Some device drivers always add other headers. 
<B>SOCK_RAW</B>

is similar to but not compatible with the obsolete 
<B>SOCK_PACKET</B>

of Linux 2.0.
<P>
<B>SOCK_DGRAM </B>

operates on a slightly higher level. The physical header is removed before
the packet is passed to the user.  Packets sent through a
<B>SOCK_DGRAM</B>

packet socket get a suitable physical layer header based on the information
in the 
<B>sockaddr_ll </B>

destination address before they are queued.
<P>
By default all packets of the specified protocol type
are passed to a packet socket. To only get packets from a specific interface
use
<B><A HREF="../man2/bind.2.html">bind</A></B>(2)

specifying an address in a
<B>struct sockaddr_ll</B>

to bind the packet socket to an interface. Only the 
<B>sll_protocol </B>

and the
<B>sll_ifindex</B>

address fields are used for purposes of binding.
<P>
The
<B><A HREF="../man2/connect.2.html">connect</A></B>(2)

operation is not supported on packet sockets.
<P>
When the
<B>MSG_TRUNC</B>

flag is passed to
<B><A HREF="../man2/recvmsg.2.html">recvmsg</A></B>(2),

<B><A HREF="../man2/recv.2.html">recv</A></B>(2),

<B><A HREF="../man2/recvfrom.2.html">recvfrom</A></B>(2)

the real length of the packet on the wire is always returned, even when it
is longer than the buffer.
<P>
<A NAME="lbAE">&nbsp;</A>
<H2>ADDRESS TYPES</H2>

The sockaddr_ll is a device independent physical layer address.
<P>
<DL COMPACT><DT><DD>
<PRE>

struct sockaddr_ll {
    unsigned short  sll_family;    /* Always AF_PACKET */
    unsigned short  sll_protocol;  /* Physical layer protocol */
    int             sll_ifindex;   /* Interface number */
    unsigned short  sll_hatype;    /* Header type */
    unsigned char   sll_pkttype;   /* Packet type */
    unsigned char   sll_halen;     /* Length of address */ 
    unsigned char   sll_addr[8];   /* Physical layer address */
};

</PRE>

</DL>

<P>
<B>sll_protocol </B>

is the standard ethernet protocol type in network order as defined
in the
<B>linux/if_ether.h   </B>

include file.  It defaults to the socket's protocol.
<B>sll_ifindex </B>

is the interface index of the interface
(see
<B><A HREF="../man7/netdevice.7.html">netdevice</A></B>(7));

0 matches any interface (only legal for binding). 
<B>sll_hatype </B>

is a ARP type as defined in the 
<B>linux/if_arp.h </B>

include file.
<B>sll_pkttype </B>

contains the packet type. Valid types are 
<B>PACKET_HOST</B>

for a packet addressed to the local host,
<B>PACKET_BROADCAST</B>

for a physical layer broadcast packet,
<B>PACKET_MULTICAST</B>

for a packet sent to a physical layer multicast address,
<B>PACKET_OTHERHOST</B>

for a packet to some other host that has been caught by a device driver
in promiscuous mode, and
<B>PACKET_OUTGOING</B>

for a packet originated from the local host that is looped back to a packet
socket. These types make only sense for receiving.
<B>sll_addr</B>

and
<B>sll_halen</B>

contain the physical layer (e.g. IEEE 802.3) address and its length. The 
exact interpretation depends on the device.
<P>
When you send packets it is enough to specify
<B>sll_family</B>,

<B>sll_addr</B>,

<B>sll_halen</B>,

<B>sll_ifindex</B>.

The other fields should be 0.
<B>sll_hatype</B>

and
<B>sll_pkttype</B>

are set on received packets for your information.
For bind only
<B>sll_protocol</B>

and
<B>sll_ifindex</B>

are used.
<P>
<A NAME="lbAF">&nbsp;</A>
<H2>SOCKET OPTIONS</H2>

Packet sockets can be used to configure physical layer multicasting 
and promiscuous mode. It works by calling 
<B><A HREF="../man2/setsockopt.2.html">setsockopt</A></B>(2)

on a packet socket for SOL_PACKET and one of the options 
<B>PACKET_ADD_MEMBERSHIP </B>

to add a binding or 
<B>PACKET_DROP_MEMBERSHIP</B>

to drop it.
They both expect a 
<B>packet_mreq</B>

structure as argument:
<P>
<DL COMPACT><DT><DD>
<PRE>

struct packet_mreq
{
    int             mr_ifindex;    /* interface index */
    unsigned short  mr_type;       /* action */
    unsigned short  mr_alen;       /* address length */
    unsigned char   mr_address[8]; /* physical layer address */ 
};

</PRE>

</DL>

<P>
<B>mr_ifindex</B>

contains the interface index for the interface whose status
should be changed.
The
<B>mr_type</B>

parameter specifies which action to perform.
<B>PACKET_MR_PROMISC</B>

enables receiving all packets on a shared medium (often known as
``promiscuous mode''),
<B>PACKET_MR_MULTICAST </B>

binds the socket to the physical layer multicast group specified in 
<B>mr_address</B>

and
<B>mr_alen</B>,

and
<B>PACKET_MR_ALLMULTI</B>

sets the socket up to receive all multicast packets arriving at the interface. 
<P>
In addition the traditional ioctls 
<B>SIOCSIFFLAGS</B>,

<B>SIOCADDMULTI</B>,

<B>SIOCDELMULTI</B>

can be used for the same purpose.
<P>
<P>
<A NAME="lbAG">&nbsp;</A>
<H2>IOCTLS</H2>

<B>SIOCGSTAMP</B>

can be used to receive the time stamp of the last received packet. Argument
is a 
<B>struct timeval.</B>

<P>
In addition all standard ioctls defined in
<B><A HREF="../man7/netdevice.7.html">netdevice</A></B>(7)

and 
<B><A HREF="../man7/socket.7.html">socket</A></B>(7)

are valid on packet sockets.
<P>
<A NAME="lbAH">&nbsp;</A>
<H2>ERROR HANDLING</H2>

Packet sockets do no error handling other than errors occurred while passing
the packet to the device driver. They don't have the concept of a pending
error.
<P>
<A NAME="lbAI">&nbsp;</A>
<H2>COMPATIBILITY</H2>

In Linux 2.0, the only way to get a packet socket was by calling
<B>socket(PF_INET, SOCK_PACKET, </B><I>protocol</I><B>)</B>.

This is still supported but strongly deprecated.
The main difference between the two methods is that
<B>SOCK_PACKET</B>

uses the old
<B>struct sockaddr_pkt</B>

to specify an interface, which doesn't provide physical layer independence.
<P>
<DL COMPACT><DT><DD>
<PRE>

struct sockaddr_pkt
{
    unsigned short  spkt_family;
    unsigned char   spkt_device[14];
    unsigned short  spkt_protocol;
};

</PRE>

</DL>

<P>
<B>spkt_family </B>

contains 
the device type,
<B>spkt_protocol </B>

is the IEEE 802.3 protocol type as defined in
<B>&lt;<A HREF="file:///usr/include/sys/if_ether.h">sys/if_ether.h</A>&gt;</B>

and
<B>spkt_device </B>

is the device name as a null terminated string, e.g. eth0.  
<P>
This structure is obsolete and should not be used in new code.
<P>
<A NAME="lbAJ">&nbsp;</A>
<H2>NOTES</H2>

For portable programs it is suggested to use 
<B>PF_PACKET</B>

via 
<B><A HREF="../man3/pcap.3.html">pcap</A></B>(3);

although this only covers a subset of the
<B>PF_PACKET</B>

features.
<P>
The
<B>SOCK_DGRAM</B>

packet sockets make no attempt to create or parse the IEEE 802.2 LLC header
for a IEEE 802.3 frame. 
When 
<B>ETH_P_802_3 </B>

is specified as protocol for sending the kernel creates the 
802.3 frame and fills out the length field; the user has to supply the LLC 
header to get a fully conforming packet. Incoming 802.3 packets are not 
multiplexed on the DSAP/SSAP protocol fields; instead they are supplied to the 
user as protocol 
<B>ETH_P_802_2</B>

with the LLC header prepended. It is thus not possible to bind to
<B>ETH_P_802_3;</B>

bind to 
<B>ETH_P_802_2 </B>

instead and do the protocol multiplex yourself.
The default for sending is the standard Ethernet DIX 
encapsulation with the protocol filled in. 
<P>
Packet sockets are not subject to the input or output firewall chains.
<P>
<A NAME="lbAK">&nbsp;</A>
<H2>ERRORS</H2>

<DL COMPACT>
<DT><B>ENETDOWN</B>

<DD>
Interface is not up. 
<P>
<DT><B>ENOTCONN</B>

<DD>
No interface address passed.
<P>
<DT><B>ENODEV</B>

<DD>
Unknown device name or interface index specified in interface address.
<P>
<DT><B>EMSGSIZE</B>

<DD>
Packet is bigger than interface MTU. 
<P>
<DT><B>ENOBUFS</B>

<DD>
Not enough memory to allocate the packet.
<P>
<DT><B>EFAULT</B>

<DD>
User passed invalid memory address.
<P>
<DT><B>EINVAL</B>

<DD>
Invalid argument.
<P>
<DT><B>ENXIO</B>

<DD>
Interface address contained illegal interface index.
<P>
<DT><B>EPERM</B>

<DD>
User has insufficient privileges to carry out this operation.
<P>
<DT><B>EADDRNOTAVAIL</B>

<DD>
Unknown multicast group address passed.
<P>
<DT><B>ENOENT</B>

<DD>
No packet received.
<P>
In addition other errors may be generated by the low-level driver.
</DL>
<A NAME="lbAL">&nbsp;</A>
<H2>VERSIONS</H2>

<B>PF_PACKET </B>

is a new feature in Linux 2.2. Earlier Linux versions supported only
<B>SOCK_PACKET</B>.

<P>
<A NAME="lbAM">&nbsp;</A>
<H2>BUGS</H2>

glibc 2.1 does not have a define for 
<B>SOL_PACKET</B>.

The suggested workaround is to use
<DL COMPACT><DT><DD>
<PRE>
#ifndef SOL_PACKET
#define SOL_PACKET 263
#endif
</PRE>

</DL>

This is fixed in later glibc versions and also does not occur on libc5 systems.
<P>
The IEEE 802.2/803.3 LLC handling could be considered as a bug. 
<P>
Socket filters are not documented.
<P>
The
<I>MSG_TRUNC</I>

<B>recvmsg</B>()

extension is an ugly hack and should be replaced by a control message.
There is currently no way to get the original destination address of
packets via SOCK_DGRAM.
<P>
<A NAME="lbAN">&nbsp;</A>
<H2>HISTORICAL NOTE</H2>

The include file
<I>&lt;<A HREF="file:///usr/include/netpacket/packet.h">netpacket/packet.h</A>&gt;</I>

is present since glibc2.1. Older systems need
<P>
<PRE>
<B>#include &lt;<A HREF="file:///usr/include/asm/types.h">asm/types.h</A>&gt;</B>
<BR>
<B>#include &lt;<A HREF="file:///usr/include/linux/if_packet.h">linux/if_packet.h</A>&gt;</B>
<BR>
<B>#include &lt;<A HREF="file:///usr/include/linux/if_ether.h">linux/if_ether.h</A>&gt;  /* The L2 protocols */</B>
<BR>
</PRE>





<A NAME="lbAO">&nbsp;</A>
<H2>SEE ALSO</H2>

<B><A HREF="../man2/socket.2.html">socket</A></B>(2),

<B><A HREF="../man3/pcap.3.html">pcap</A></B>(3),

<B><A HREF="../man7/capabilities.7.html">capabilities</A></B>(7),

<B><A HREF="../man7/ip.7.html">ip</A></B>(7),

<B><A HREF="../man7/raw.7.html">raw</A></B>(7),

<B><A HREF="../man7/socket.7.html">socket</A></B>(7)

<P>
RFC&nbsp;894 for the standard IP Ethernet encapsulation.
<P>
RFC&nbsp;1700 for the IEEE 802.3 IP encapsulation.
<P>
The 
<I>&lt;<A HREF="file:///usr/include/linux/if_ether.h">linux/if_ether.h</A>&gt;</I>

include file for physical layer protocols.
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DT><A HREF="#lbAC">SYNOPSIS</A><DD>
<DT><A HREF="#lbAD">DESCRIPTION</A><DD>
<DT><A HREF="#lbAE">ADDRESS TYPES</A><DD>
<DT><A HREF="#lbAF">SOCKET OPTIONS</A><DD>
<DT><A HREF="#lbAG">IOCTLS</A><DD>
<DT><A HREF="#lbAH">ERROR HANDLING</A><DD>
<DT><A HREF="#lbAI">COMPATIBILITY</A><DD>
<DT><A HREF="#lbAJ">NOTES</A><DD>
<DT><A HREF="#lbAK">ERRORS</A><DD>
<DT><A HREF="#lbAL">VERSIONS</A><DD>
<DT><A HREF="#lbAM">BUGS</A><DD>
<DT><A HREF="#lbAN">HISTORICAL NOTE</A><DD>
<DT><A HREF="#lbAO">SEE ALSO</A><DD>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 02:16:45 GMT, April 20, 2020
</BODY>
</HTML>
